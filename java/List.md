## Java List

### ArrayList

底层基于数组实现，查询快，增删慢

#### transient

将不需要序列化的属性前添加关键字transient

回到ArrayList

初始化容量10，动态扩容，新增一个1.5倍容量数组，然后把原数组中数据复制到新数组，再把新数组赋值给原来数组对象

### LinkedList

底层基于双向链表实现，查询慢，增删快

不需要指定初始容量，链表中任何一个存储单元都可以通过向前或向后指针获取到前面或后面的存储单元。

查询index位置数据时，先计算链表总长度一半的值，判断index在这个值的左边还是右边，再决定从头还是尾节点开始遍历

LinkedList对内存的占用也比较大，每个Node都维护着前后指向地址的节点。

### 二者比较

链表的Node结构似乎更占空间，但数组扩容时默认扩大到容量的1.5倍，如果只添加1个元素，那有将近原来一半的空间被浪费。因此在 **数据量很大又实时添加数据** 的情况下，数组占用的空间不一定比链表小。

但还需要考虑到transient，其修饰的变量不会被序列化，ArrayList里的数组元素用transient修饰，并重写了writeObject方法，因此在序列化的时候只序列化size大小的元素而不是capacity大小的元素。

**结论：**一般情况，链表占空间大，因为每个节点要维护指向前后地址的两个节点，但数据量超过ArrayList的默认临时值时，ArrayList占用空间也不小，因为扩容要浪费将近原来一半空间。不过ArrayList数组变量是transient修饰的，如果集合本身做序列化操作的话，ArrayList这部分多余的空间不会被序列化。

