java对象在内存中占用的空间分为3类：

* 对象头（Header）
* 实例数据（Instance Data）
* 对齐填充（Padding）

而我们常说的基础数据类型大小主要是指第二类实例数据。

**对象头**

HotSpot虚拟机的对象头包括两部分信息：

* markword，用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。 
* klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

**特例：数组**

如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度，也就是一个int类型的对象，占4字节。

**对齐**

最后一块对齐填充空间并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。这是由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。

**实例**

```java
// 对象A： 对象头12B + 内部对象s引用 4B + 内部对象i 基础类型int 4B + 对齐 4B = 24B
// 内部对象s 对象头12B + 2个内部的int类型8B + 内部的char[]引用 4B + 对齐0B = 24B
// 内部对象str的内部对象char数组 对象头12B + 数组长度4B + 对齐0B = 16B
// 总： 对象A 24+ 内部对象s 24B + 内部对象s的内部对象char数组 16B =64B
class A {
  String s = new String();
  int i = 0;
}

// 对象B：对象头12B + 内部对象s引用 4B + 内部对象i 基础类型int 4B + 对齐 4B = 24B
// s没有被分配堆内存空间
// 总： 对象B 24B
class B {
  String s;
  int i = 0;
}
```

**总结**

对象在jvm中不是完全连续的，这是由于GC的原因，总会出现散乱的内存。这就导致了jvm必须为每个对象分配一段内存空间来存储其引用的指针，再结合对象的其他必须的元数据，使得对象在持有真实数据的基础上还需要维护额外的数据。

在写java代码需要小心这些jvm内存陷阱。