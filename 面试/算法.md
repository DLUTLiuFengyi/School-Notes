---
typora-root-url: pic
---

## 算法

### 链表

#### LRU

#### 反转链表

```java
pre = null;
next = cur.next;
cur.next = pre;
pre = cur;
cur = next;
```

### 单调栈

栈内元素单调增或单调减

* 视野
* 区间最大元素

### 查找

#### 二分查找

#### 快速选择

topk问题

快速选择的总体思路与快速排序一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从O(nlogn)至O(n)，不过最坏情况仍然是O(n2)。

```java
class Solution {
    /**
 *  解法0. 堆 O(klogn)
 *  解法1. 快速选择: O(n)
 */
    public int findKthLargest(int[] nums, int k) {
        if (nums.length == 0 || nums == null) return 0;
        int left = 0, right = nums.length - 1;
        while (true) {
            int position = partition(nums, left, right);
            if (position == k - 1) return nums[position]; //每一轮返回当前pivot的最终位置，它的位置就是第几大的，如果刚好是第K大的数
            else if (position > k - 1) right = position - 1; //二分的思想
            else left = position + 1;
        }
    }

    private int partition(int[] nums, int left, int right) {
        int pivot = left;
        int l = left + 1; //记住这里l是left + 1
        int r = right;
        while (l <= r) {
            while (l <= r && nums[l] >= nums[pivot]) l++; //从左边找到第一个小于nums[pivot]的数
            while (l <= r && nums[r] <= nums[pivot]) r--; //从右边找到第一个大于nums[pivot]的数
            if (l <= r && nums[l] < nums[pivot] && nums[r] > nums[pivot]) {
                swap(nums, l++, r--);
            }
        }
        swap(nums, pivot, r); //交换pivot到它所属的最终位置，也就是在r的位置，因为此时r的左边都比r大，右边都比r小
        return r; //返回最终pivot的位置
    }

    private void swap(int[] nums, int l, int r) {
        int tmp = nums[l];
        nums[l] = nums[r];
        nums[r] = tmp;
    }
}
```

### 树

#### 红黑树

没那么严格的avl树，avl要求所有节点左右子树高度差绝对值不超过1，因此会产生大量的树结构调整操作，维护高度平衡付出的代价很可能比严格平衡收获的代价高

avl适用于增删次数少、查找多的情况

#### DFS

#### 线段树

求区间和

遍历普通数组：修改快（只修改一个元素），求和慢（一个一个求和）

前缀和：修改慢（要修改元素后面的前缀和都要改），求和快（两个元素作减法）

原理是将数据划分成多个小区间，判断题目要求的区间由哪些小区间组成，要修改题目要求区间内的元素的话，只需要修改那些小区间的值即可

### 动态规划

#### 背包

#### 最长回文子串

#### 最长重复子串

### 排序

![](D:/ideaprojects/School-Notes/面试/pic/sort.png)

#### 堆排序

##### 时间复杂度

堆的存储表示是顺序的。因为堆所对应的二叉树为完全二叉树，而完全二叉树通常采用顺序存储方式。

当想得到一个序列中第k个最小的元素之前的部分排序序列，最好采用堆排序。堆排序的时间复杂度是O(n*logn)

因为构建堆的复杂度是O(n)，然后排序过程中，每一次根节点都会与最后的叶子节点交换，一共是n次，而每一次交换都会进行堆的调整以适应大顶堆/小顶堆，复杂度是logn，因此一共是O(n) + O(nlogn)，近似为O(nlogn)

##### 建堆复杂度

近似O(n)

最后一层共有2^(h-1)个节点，每个节点（的父节点）最多只需下调1次；倒数第二层共有2^(h-2)个节点，每个节点最多下调2次；... 第一层共有2^(h-h)个节点，顶点最多下调h次

##### 稳定性

不稳定。因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况

##### 图片叙述

构建大顶堆

<img src="/dui1.png" style="zoom:70%;" />

第（3）步开始，排序

<img src="/dui2.png" style="zoom:80%;" />

##### 大根堆 小根堆

每个结点的关键字都不小于其孩子结点的关键字，这样的堆称为大根堆

每个结点的关键字都不大于其孩子结点的关键字，这样的堆称为小根堆

