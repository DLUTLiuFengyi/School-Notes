## 计算机网络

### TCP

#### 三次握手

客户端、服务器端都要确定对方有发送和接收能力

1. 客户端向服务端发送了SYN报文，服务端确认接收了SYN报文
2. 服务端确认接收了SYN报文后，会返回向客户端发送SYN报文和ACK确认报文
3. 客户端接收到SYN报文和ACK报文，发送ACK报文，建立起连接

#### 四次挥手

比三次握手多了一个情景：数据正在传输，还没传输完

1. 客户端向服务端发送数据，发送完成后会发送一个FIN报文，告诉服务端数据发送完毕
2. 服务端接收到FIN报文，将ACK报文返回客户端，告诉客户端已接收到数据
3. 服务端处理完数据后再发送一个FIN报文给客户端，告诉客户端自己已处理完毕
4. 客户端接收到服务端发来的FIN报文后就能确认这次的数据传输完毕

#### SSL三次握手

属于应用层 HTTPS，可认证用户和服务器，确保数据发送到正确的客户机和服务器

1. 客户端生成随机数携带版本号及加密方式，服务器判断是否是可用的加密方式，可用，进入下一步
2. 服务端生成第二个随机数，和CA证书（公钥）发送给客户端
3. 客户端生成第三个随机数（密钥），且使用CA证书中的公钥对密钥进行加密，再次发给服务器。服务器会接收到这第三个随机数，且利用证书中的私钥将其解密，最后双方都会生成一个对话密钥

前2次是明文，最后一次是加密的（公钥加密，私钥解密，非对称加密）

#### 长连接 短连接

HTTP的长连接和短连接本质上是TCP长连接和短连接

HTTP1.0默认用短连接：客户端和服务器每进行一次HTTP操作（客户端访问某个web资源），就建立一次连接，任务结束就中断连接

HTTP1.1起，默认用长连接，一个网页打开完成后，C与S之间用于传输HTTP数据的TCP连接不会关闭。

并发量大用短连接好，避免多个客户端一直占用服务器资源。

#### 冷启动 慢启动

#### 流量控制

控制发送方发送速率，保证接收方来得及接收

使用 **滑动窗口** 实现流量控制。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。

#### 拥塞控制

1. 慢启动

2. 拥塞避免

3. 快重传和快恢复

   能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 

### TCP与UDP

* 前有连接，开始传输实际数据前c与s必须建立连接，结束时也要结束连接
* 前是一对一；后是一对多、多对多
* 前保证数据按序发送，超时重传；后是努力交付
* 前耗资源多，TCP首部20个字节（不算可选）；UDF首部8个字节
* 前有流量控制和拥塞控制；后的发送端速率不受网络拥堵影响
* 前是面向字节流传输，把app发来的数据看成一连串字节流，等buffer缓冲了一定的字节就发送一次；后是面向报文传输，app交给UDP多长报文，UDP就照样发送，即一次发送一个报文
* 前用于HTTP，FTP，SSH，SMTP；后用于流媒体，实时游戏（自定义可靠UDP）（CS、Unity3D），物联网，QQ文件传输、QQ语音、QQ视频

#### QQ是UDP为主TCP为辅

QQ既有TCP也有UDP，UDP为主，通过上层协议来保证可靠传输。

* 因为一台服务器要同时容纳十几万的并发连接，因此服务器端只有用UDP协议与客户端通信才能保证这种超大规模服务。

  采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送，延迟会越来越大。

* QQ客户端之间消息传递也采用UDP，因为网络环境复杂，且很多用户采用通过代理服务器共享一条线路上网，这种复杂情况下客户端之间彼此建立起TCP连接概率较小，严重影响传送信息效率。而UDP包能穿透大部分代理服务器，因此用UDP作为主要通信协议。

* 采用UDP，通过服务器中转的方式。用上层协议保证可靠：如果客户端使用UDP发出消息后，服务器收到该包，需要用UDP发回一个应答包，如此保证无遗漏传输。

  客户端看到“消息发送失败”但对方又收到这个消息，这是因为客户端发出的消息服务器已收到并转发成功，但客户端由于网络原没有收到服务器的应答包。

1. 登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。
2. 登陆之后，会有一个TCP连接来保持在线状态。
3. 和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。
   如果是在内网里面的两个客户端传文件，QQ采用的是P2P技术，不需要服务器中转。

### Socket

send函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。

recv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。

send是不是直接把数据发给服务端?
 不是，要想发数据，必须得通过**网卡**发送数据，应用程序是无法直接通过网卡发送数据的，它需要调用操作**系统接口**，也就是说，应用程序把发送的数据**先写入到发送缓冲区**(内存中的一片空间)，再由操作系统控制网卡把发送缓冲区的数据发送给服务端网卡 。

recv是不是直接从客户端接收数据?
 不是，应用软件是无法直接通过网卡接收数据的，它需要调用操作**系统接口**，由操作系统通过**网卡**接收数据，把接收的数据**写入到接收缓冲区**(内存中的一片空间），应用程序再从接收缓存区获取客户端发送的数据。

**send函数**

```c
int send( SOCKET s, const char FAR *buf, int len, int flags );
// 第一个参数指定发送端套接字描述符；
// 第二个参数指明一个存放应用程序要发送数据的缓冲区；
// 第三个参数指明实际要发送的数据的字节数；
// 第四个参数一般置0。 
```

同步Socket的send函数的执行流程 当调用该函数时：

  （1）先比较待发送数据len不能大于socket对象s的缓冲区长度

  （2）先检查协议是否正在发送s的缓冲区中的数据，如果是就等待协议把数据发送完，如果还没有发送或者缓冲区中没有数据，那么就比较s的发送缓冲区的剩余空间和len

  （3）如果len大于剩余空间大小，send就一直等待协议把s的发送缓冲中的数据发送完

  （4）如果len小于剩余空间大小，send就仅仅把buf中的数据copy到剩余空间里（注意并不是send把s的缓冲区中的数据传到连接的另一端的，那是协议传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里）。

如果send函数copy数据成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。

  要注意send函数把buf中的数据成功copy到s的发送缓冲区的剩余空间里后它就返回了，但是此时这些数据并不一定马上被传到连接的另一端。如果协议在后续的传送过程中出现网络错误的话，那么下一个Socket函数就会返回SOCKET_ERROR。（每一个除send外的Socket函数在执行的最开始总要先等待套接字的发送缓冲中的数据被协议传送完毕才能继续，如果在等待时出现网络错误，那么该Socket函数就返回 SOCKET_ERROR）

**recv函数**

类似send

先等待s的发送缓冲区中的数据被协议传送完毕

检查s的接收缓冲区，如果其中没有数据或者协议正在接收数据，那么recv就一直等待，当协议把数据接收完毕，recv就把s的接收缓冲区中的数据copy到buf对象中

### IO

https://blog.csdn.net/baixiaoshi/article/details/48708347?utm_source=copy

### 层

#### TCP/IP五层模型

* 应用层

  上层数据

  HTTP, FTP, SMTP, DNS

* 传输层

  数据段（TPC头部+上层数据），又叫数据报

  TCP/UDP

* 网络层

  数据包（IP头部+TCP头部+上层数据）

  IP, ARP, ICMP, IGMP

* 数据链路层

  数据帧（MAC头部+IP头部+TCP头部+上层数据）

* 物理层

  比特流

DHCP：动态主机配置协议，局域网中的计算机分配动态ip。客户端向server询问，说自己想用DHCP方式使用ip，服务器给它分配一个ip，客户端就能用这个ip上网

HTTP：超文本传输协议，简单的请求-响应协议

HTTPs：在HTTP基础上进行加密和身份认证保证传输的安全性

FTP：允许用户存取指定类型与格式的文件，以及交互功能

SMTP：简单邮件传输协议，从源到目的地址的邮件传送规则

DNS域名解析系统：将域名解析为ip地址并提供访问

ssh协议：建立在应用层和传输层基础上的安全协议

TCP：将数据分成IP段和，安全性高，传输数据前要握手

UDP：用户数据报协议，安全性不高，响应比TCP快

IP：负责计算机之间的通信，负责在因特网上发送和接收数据包

ICMP：用于在ip主机、路由器之间传递控制信息

IGMP：internet组管理协议

ARP：将ip地址解析成MAC地址

RARP：将MAC地址解析成ip地址

#### 数据封装与解封装

应用层发送上层数据经过传输层添加TCP头部，到达网络层添加IP头部，到达逻辑链路层添加MAC头部，到达物理层转化为010101的电信号等物理信号。

物理层接收到010101的物理信号后传递至逻辑链路层拆解MAC头部，数据到达网络层后拆解IP头部，到达传输层后拆解TCP头部，最后送达至应用层。

**注意：**每层都有数据段MSS的概念，指该层最大可容纳的有效数据长度，数据段加上头部就是该层的最大传输单元MTU

#### OSI七层模型

* 应用层：各种应用程序协议
* 表示层：信息的语法语义及它们的关联，如加密解密、转换翻译、压缩解压缩
* 会话层：不同机器上的用户之间建立及管理会话
* 传输层：接收上一层的数据，在必要时将数据进行**分割**，并将这些数据交给网络层，且保证这些数据段有效到达对端
* 网络层：控制子网的允许，网络路由和寻址问题
* 数据链路层：物理寻址，同时将原始比特流转变成逻辑传输线路
* 物理层：机械电子定时接口通信信道上的原始比特流传输

传输层TCP与网络层IP都可以将数据切片

### DNS

域名服务器：将域名解析成ip地址

用户上网使用域名来访问网站

用户提交的请求不会直接发送给想要访问的网站，而是

* 首先发给域名服务器，服务器把域名解析成ip地址，返回给用户
* 用户收到ip地址，向该ip地址发起请求

#### 两种解析方法

1. 递归查询

   一般客户机与服务器之间属递归查询，即当客户机向dns服务器发出请求后，若dns服务器本身不能解析，则会向另外的dns服务器发出查询请求，即自己替客户端查询，而不用客户端自己查，得到结果后转交给客户机

2. 迭代查询

   当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。

#### DNS负载均衡

如果一个域名指向了多个IP地址，在每次域名解析时，DNS只要选一个返回给用户，就能够实现服务器集群的负载均衡。

##### 具体做法

设置一个调度策略，接下来的负载均衡完全由DNS服务器实现。当用户向我们的域名发起请求时，DNS服务器会自动根据我们之前设定好的策略选择一个合适的IP返回给用户，用户再向该IP发起请求。

* 随机分配
* 轮询
* 根据请求者的地域分配离他最近的服务器

##### 优点

* 最大的优点是配置简单

  服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。

* 具有较强的扩展性

  你完全可以为一个域名解析较多的IP，而且不用担心性能问题。

##### 缺点

* 不能方便地控制调度者（DNS）

  由于把集群调度权交给了DNS服务器，我们没办法随心所欲地控制调度者，没办法定制调度策略。

* DNS服务器不能了解每台服务器负载情况

  没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。

* DNS服务器对故障ip有缓存

  当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态DNS来解决。

#### 动态DNS

DNS系统能够自动更新DNS记录。本地DNS数据库可以即时更新，把域名指向一个可能经常改变的IP地址。

#### DNS缓存

一条域名的DNS记录会在本地有两种缓存：浏览器缓存和OS缓存。在浏览器中访问的时候，会优先访问浏览器缓存，

如果未命中则访问OS缓存，最后再访问DNS服务器(一般是ISP提供)，然后DNS服务器会递归式的查找域名记录，然后返回。

### 子网掩码

1、用于将一个大的IP网络划分为若干小的子网络：

有的网络多则几百台，有的只有区区几台，这样就浪费了很多IP地址，所以要划分子网。使用子网可以提高网络应用的效率。

2、用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上：

子网掩码一旦设置，网络地址和主机地址就固定了。子网一个最显著的特征就是具有子网掩码。与IP地址相同，子网掩码的长度也是32位，也可以使用十进制的形式。

## 操作系统

### 系统调用

我们运行的程序基本都是运行在用户态，如果要调用操作系统提供的系统态级别的子功能，那就需要系统调用

凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并**由操作系统代为**完成。

### 进程控制块 PCB

是OS中最重要的记录型数据结构，记录了OS所需的、用于描述进程当前情况以及控制进程运行的全部信息	

### 进程与线程

进程是资源分配的基本单位，线程是进程划分成的更小的运行单位，一个进程在其执行的过程中可以产生多个线程。（线程是cpu调度的基本单位）

### 进程间通信

#### 管道

一种特殊的文件，只存在于内存中，实质是内核缓冲区

无名管道PIPE 半双工 父子进程

命名管道FIFO 半双工 允许无血缘进程间通信 在磁盘上有对应的节点，自身只有名字和访问节点的权限

#### 信号 Signal

比较复杂的通信方式，用于通知接收进程某个事件已经发生

#### 消息队列

是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。

消息队列 克服了管道信号传递信息少、只能承载无格式字节流及缓冲区大小受限等缺点

#### 共享存储（内存）

共享存储 最快的IPC 映射一段能被其他进程访问的内存，此内存由一个进程创建，但多个进程都可以访问 常与信号量配合

这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。

因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。

#### 信号量 Semaphores

是一个计数器

信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

信号量 计数器 可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

#### 套接字socket

可用于不同机器间的进程通信

套接字是**支持 TCP/IP 的网络通信的基本操作单元**，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

### 线程

一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

#### 线程5种状态

实现runnable接口和继承Thread可得一个线程类，new一个实例出来，就进入初始态

* 初始

* 可运行

  位于可运行线程池中，等待被线程调度选择，获取cpu使用权

  * 线程对象创建后，其他线程如main线程调用了该线程的**start()**方法
  * 当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，线程也会进入可运行态
  * 当前线程时间片用完，调用当前线程的yield()方法，当前线程也会进入可运行态
  * 锁池中的线程拿到对象锁后，也会进入可运行态

* 运行

  可运行的线程获得了cpu时间片，执行程序代码

* 阻塞**（重要）**

  线程因某种原因放弃了cpu使用权，暂时停止运行。

  直到线程进入可运行状态才有机会再次获得cpu使用权

  * 等待阻塞：运行态的线程执行**wait()方法**，jvm会把该线程放入阻塞队列中
  * 同步阻塞：运行态的线程在获取对象**同步锁**时，若该同步锁被其他线程占用，则jvm会把该线程放入锁池
  * 其他阻塞：运行态的线程执行**Thread.sleep()或t.join()方法**，或者**发出了I/O请求**，jvm会把该线程置为**阻塞**状态。当sleep超时、join等待线程终止或超时、**I/O处理完毕**时，线程重新转入**可运行状态**。

* 死亡

  线程run(), main()方法执行结束，或者因异常退出run()方法

#### sleep与wait区别

Wait()是等待别人释放资源，Sleep()是自己占用资源，去做等待

IO的阻塞相当于是sleep，虽然能停止但不释放资源。NIO采用IO multiplexing(IO多路复用，也叫异步阻塞IO，使用selector帮你去监听感兴趣的IO路径)。

* sleep是线程类Thread 的方法，它是使当前线程暂时睡眠，可以放在任何位置。而wait是Object类的方法，它是使当前线程暂时放弃对象的使用权进行等待，必须放在同步方法或同步块里。
* sleep使用的时候，线程并不会放弃对象的使用权，即不会释放对象锁，所以在同步方法或同步块中使用sleep，一个线程访问时，其他的线程也是无法访问的。wait是会释放对象锁的，就是当前线程放弃对象的使用权，让其他的线程可以访问。
* sleep只是暂时休眠一定时间，时间到了之后，自动恢复运行，不需另外的线程唤醒。线程执行wait方法时，需要另一个线程调用notify进行唤醒。

#### 拿到IO资源后是如何唤醒线程的？



### 线程间同步

线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。

1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2. **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
3. **事件(Event)** :Wait/Notify：通过**通知操作**的方式来保持**多线程同步**，还可以方便的实现多线程优先级的比较操作

#### Wait/Notify机制

举个栗子：餐厅里，厨师做好菜之后，通知等待中的服务员就是一个简单的等待通知机制

wait使线程停止运行，notify通知停止的线程继续执行

* wait：使当前执行代码的线程进入等待

  用来将当前线程置入“预执行队列”中，在wait所在的代码行处停止，直到接到通知或被终止为止。

  在wait之前，线程必须获得该对象的对象级别锁，即只有在同步方法或同步块中才能调用wait方法，wait方法执行后当前线程立即释放锁。

* notify：通知那些可能等待该对象的对象锁的**其他线程**

  notify方法在调用前，也要获得当前线程的对象级别的锁，即方法notify也要在同步方法或同步块中调用。

  在执行notify方法后，当前线程不会立马释放该对象锁，呈wait状态的线程不能立马获得该对象锁，需要等到notify所在的同步块执行完才会释放该对象锁。

### 中断

#### 含义

当出现需要时，cpu暂时停止当前程序的执行转而执行处理新情况的程序的这个过程。

#### 硬件中断与软件中断

硬件：硬件发出的中断信号，如I/O中断和硬件失效中断

* 由I/O控制器产生，用于发送信号通知操作完成等信号
* 掉电或存储器奇偶错之类故障

软件：程序中断和时钟中断

* 算数移除，除数为0
* 由处理器内部计时器产生，允许OS以一定规程执行函数（线程调度通过时钟中断实现）

#### 中断好处

有中断还是没有中断对于用户来说线程都是阻塞的，对于操作系统内核来说通过中断方式主动通知CPU的方式减少了线程轮询判断，提高了线程执行效率。

#### 流程

当外部设备的I/O模块准备好时，它会发送给CPU一个中断信号，CPU则会“立即”做出响应，暂停当前程序的处理去服务该I/O设备的程序。

当I/O设备完成一次I/O操作时，发送以下事件

* 开始I/O操作前，**处理器**将当前处理的相关信息（指令地址、必要的状态信息）保存到栈中，使得中断后可以恢复
* I/O操作完成后，**设备**给处理器发送一个中断信息
* 处理器响应中断信号
* 处理器对中断信号进行判断，若存在未响应的中断，则给产生中断信号的设备发送确认信号，确认信号使得设备取消它的中断信号
* **处理器将控制权转移给被中断程序**，被中断程序从栈中获取之前保存的信息，使得能继续执行I/O完成时的后续操作
* 处理器将**中断程序入口地址**载入到**程序计数器**中，使得程序计数器能继续执行下一个指令周期

#### 异步

调用异步操作后，API内部保存了相关状态机信息(回调信息)，线程继续执行其他操作，当操作系统内核读取数据完成时，线程调用回调方法恢复到`await`的后续操作。整个过程中线程不会因为阻塞带来导致性能损失。

### 软件开发的三层架构

高内聚低耦合

表示层UI，业务逻辑层BLL，数据访问层DAL