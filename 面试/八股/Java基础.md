---
typora-root-url: ..\pic
---

### 存放地址

栈内存中的数据是可以共享的，常量存储的数据也是可以共享的，堆则不可以

栈中的数据大小和生命周期都是确定的，而堆中的数据大小和生命周期则是不确定的

成员变量存储在其所属的对象里面，也就说对象如果是引用存放在栈中，那么对象的成员变量自然也在栈中，如果说对象是new出来的，对象存储在堆中，那么对象的成员变量也在堆中。

#### 方法区

又叫静态区，被所有线程共享，包含所有**class和static变量**，即整个程序中永远唯一的元素

方法区 = class文件信息（类信息+静态常量池） + 动态常量池

* 类信息：class内容的一个框架
* 静态常量池：class里面具体的内容，class文件被jvm加载进来后存放在方法区的一些字面量和符号引用
  * 字面量：字符串，基本类型的常量
  * 符号引用：存储字符串在常量池中的索引，类和结构的完全限定名，字段名称和描述符，方法名称和描述符
* 动态常量池：class文件被加载完后，jvm会将静态常量池中的内容**移动**到动态常量池中，将静态常量池中的部分符号引用变成直接引用（如类的静态方法或私有方法、实例构造方法、父类方法，这些方法不能被重写成其他版本，所以加载时就可以转成直接引用），而其他方法是在被第一次调用时才会将符号引用转成直接引用

#### 堆

jvm只有一个堆区被所有线程共享，堆中不存放基本类型和对象引用，只存对象本身（对象实例和数组）

#### 栈

存放函数参数和局部变量

每个线程包含一个栈区（局部方法栈 本地方法栈 程序计数器），栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中 

基础变量，局部变量，执行环境上下文，操作指令，对象的引用存在栈中，指向堆中对象对应的位置

### 编译与解释

两种皆有，编译器先将源程序编译成.class这种jvm能读懂的java字节，再用解释器解释成二进制机器码

### jdk代理模式

JDK的动态代理，是由JDK的java.lang.reflect.*包提供支持的，我们需要完成这么几个步骤：
1、 编写服务类和接口，这个是真正的服务提供者，在JDK代理中接口是必须的
2、 编写代理类，提供绑定和代理方法
JDK代理最大的缺点就是需要接口，而mybatis的Mapper就是一个接口，它采用的就是JDK的动态代理。

### JMM内存模型

<img src="/jmm1.png" style="zoom:50%;" />

volatile修饰的变量可以让线程看到别的线程修改的工作内存中的变量值  修改工作内存后马上同步到主内存中，同时每个监控MESI缓存一致性总线的线程知道了有变量在主内存中更新了，然后查看自己有没有这个变量，有的话就从主内存中读新值

<img src="/jmm2.png" style="zoom:60%;" />

### Java内存管理

#### 线程共享

* 堆：存储对象实例和数组

* 方法区：存储被jvm加载的class类信息、final常量、static静态常量等，是整个程序中永远唯一的元素
  * 运行时常量池：存储编译生成的各种字面量和符号引用，运行期间也可能将新的常量放入池中

#### 线程私有

* 虚拟机栈：java方法执行的栈帧。**每个方法从调用到执行完成的过程，都对应一个栈帧在虚拟机栈的入栈到出栈的过程。**
  * 局部变量表：保存函数参数和局部变量
  
    编译期可知的基本数据类型、对象引用、指向一条字节码指令的地址等
  
  * 操作数栈：每个函数内部也要用一个栈来计算局部变量的值
  
  * 动态链接：将这些以符号引用表示的方法转换为实际方法的直接引用
  
    在class文件里，一个方法若要调用其他方法，或者访问成员变量，则需要通过符号引用来表示
  
  * 方法出口：使当前的栈帧能够和调用者连接起来，并且让调用者的栈帧的操作数栈继续往下执行
  
    方法正常返回会把返回值压入调用者的栈帧的操作数栈，PC计数器的值就会调整到方法调用指令后面的一条指令
* 本地方法栈：native方法执行的栈帧
* 程序计数器：当前线程执行字节码的行号指示器，记录下一条所需执行的字节码指令

#### 对象的创建

new一个对象，在jvm中的流程是？

虚拟机遇到new指令时

1. 类加载：确保常量池中存放的是已解释的类，且对象所属类型已经初始化过，如果没有，则先执行类加载
2. 为新生对象分配内存：对象所需内存大小在类加载时可以确定，将确定大小的内存从java堆中划分出来
3. 将分配的内存空间初始化为0值
4. 设置对象头：类的元数据信息、哈希码、gc分代年龄等
5. 执行init方法初始化：将对象按程序员意愿初始化

#### 对象的内存布局

* Mark Word

  hashcode，gc分代年龄，锁状态标志，线程持有的锁等

* 指向class的指针

  对象指向它的类的元数据的指针，**jvm通过这个指针来确定是哪个类的实例**

* 对象的body部分

* （数组长度）

* 对齐填充

#### 函数如何通过栈实现层层返回

线程执行的基本行为是函数调用，每次函数调用的数据都是通过Java栈传递的。

Java栈的主要内容是栈帧。每次函数调用都会有一个对应的栈帧被压入Java栈，每次函数调用结束(无论是正常返回或者抛出异常)，都会有一个栈帧被弹出Java栈。

<img src="/stack1.png" style="zoom:75%;" />

方法调用在jvm中转换成的是字节码执行，**字节码执行的数据结构就是栈帧**。jvm会为每个方法分配一个栈帧，当前线程正在活动的栈帧就是栈顶的栈帧

![](/stack5.png)

<img src="/stack3.png" style="zoom:60%;" />

##### 栈帧数据结构

1. 局部变量表：保存函数参数和局部变量

   栈帧中的局部变量标准的槽位是可以复用的，如果一个局部变量表过了其作用域，那么在其作用域之后声明的变量就很有可能复用过期的局部变量表的槽位，达到节省资源的目的。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或者间接引用的对象都不会被垃圾回收。

2. 操作数栈

   与前者一样也是被组织成一个以字节为单位的数组，但与前者不同它不是通过索引访问而是通过标准的栈操作（压栈出栈）来访问。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。不同于程序计数器，Java虚拟机没有寄存器，程序计数器也无法被程序指令直接访问。Java虚拟机的指令是从操作数栈中而不是从寄存器中取得操作数的，因此它的运行方式是基于栈的而不是基于寄存器的。虽然指令也可以从其他地方取得操作数，比如从字节码流中跟随在操作码(代表指令的字节)之后的字节中或从常量池中，但是主要还是从操作数栈中获得操作数。

3. 动态链接：指向当前方法所在类型的运行时常量池的引用

   以便对当前的方法的代码实现动态链接。在class文件里，一个方法若要调用其他方法，或者访问成员变量，则需要通过符号引用来表示，**动态链接的作用就是将这些以符号引用表示的方法转换为实际方法的直接引用**。类加载的过程中将要解析尚未被解析的符号引用，并且将**对变量的访问转化访问这些变量的存储**。加载阶段或第一次使用时转化为直接引用的(将变量的访问转化为访问这些变量的存储结构所在的运行时内存位置)就叫做静态解析。

4. 方法返回地址

   方法正常返回会把返回值压入调用者的栈帧的操作数栈，**PC计数器的值就会调整到方法调用指令后面的一条指令**。这样使得当前的栈帧能够和调用者连接起来，并且让调用者的栈帧的操作数栈继续往下执行。

##### 栈上分配

栈上分配是jvm提供的一项优化技术：对那些线程私有的对象(指不能被其他线程访问到的对象)，可以将他们打散分配到栈上，而不是分配在堆上。其好处是可以在函数调用完毕自行销毁，而**不需要垃圾回收期介入**，从而提高了系统的性能。

栈上分配对象的技术基础是进行**逃逸分析**。逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。p1是成员变量，该字段可能被任何线程访问，属于逃逸对象；p2是局部变量，并且没有被返回，因此它并未发生逃逸，对这种情况，对象就可能被分配在栈上，而不是堆上。

#### 内存溢出异常

1. 堆内存溢出：对象实例数量达到堆最大容量

   * 让虚拟机在内存异常时dump当前内存堆转储快照
   * 用工具对dump出的堆转储快照分析，判断是内存泄漏还是内存溢出
     * 内存泄漏的话，查看泄漏对象的类型信息和它们到gc roots的引用链信息，分析gc收集器无法自动回收它们的原因，定位内存泄漏的代码位置。
     * 内存溢出的话检查堆参数-Xms和-Xmx（初始堆大小和最大堆大小）是否可调大；检查代码，某些对象生命周期是否过长。

2. 栈内存溢出 stackoverflow

   线程请求的栈深度大于jvm所允许的最大深度 或者 jvm扩展栈时无法申请足够的内存空间

   * 检查代码中是否有过度递归
   * 配置-Xss增大每个线程的栈内存容量（当会减少工作线程数）

### 加载一个类

1. 加载：javac编译成的字节码文件.class文件被类加载器加载到jvm中，并存储在方法区中，然后将其转换为Class对象实例，这个Class对象日后会作为方法区中该类的各种数据的访问入口。

2. 连接

   将加载到jvm中的字节流的类数据信息合并到jvm的runtime状态中

   1. 验证：类数据信息是否符合class文件规范，语法是否正确（final类型是否有子类），类成员的访问修饰符是否允许访问等
   2. 准备：为static常量分配空间，并初始化（系统的初始化 与程序无关）；final修饰的静态变量会直接赋值
   3. 解析：将常量池中所有符号引用->直接引用（内存地址）（得到类或字段、方法在内存中的指针或偏移量，以便直接调用该方法）

3. 初始化：给static按程序要求赋值，如果执行的是static代码块，那么在初始化阶段jvm就会执行static代码中定义的所有操作。优先对父类初始化。多线程中确保只允许其中一个线程执行初始化，其余等待。

### hashcode

`hashCode()` 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。

用来缩小查找成本，不必要一直都直接用equals，而是先用hashcode，地址相等后再用equals进一步判断

**为什么重写 `equals` 时必须重写 `hashCode` 方法？**

`hashCode()`的默认行为是对堆上的对象产生独特地址。如果没有重写 `hashCode()`，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。**因此，equals 方法被覆盖过，则 `hashCode` 方法也必须被覆盖。**

**为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？**

因为 `hashCode()` 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关。

### 常量池技术

java中有很多东西不会在运行过程中变化，编译器将源程序编译成class文件后，会用一部分字节分类存储这些代码。而这些字节我们就称为常量池。

常量池的出现是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复创建相等变量时节省了很多时间。

**常量池存在于方法区**

Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。

```java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true
Integer i11 = 333;
Integer i22 = 333;
System.out.println(i11 == i22);// 输出 false
Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false

Integer i1 = 40; //常量池技术
Integer i2 = new Integer(40); //创建新对象
System.out.println(i1 == i2);//输出 false
```

### equals

**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。

**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

- 情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
- 情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

### Set

```java
Set 不会存储重复的元素
用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。

对象的相等性
引用到堆上同一个对象的两个引用是相等的。如果对两个引用调用hashCode方法，会得到相同的结果，如果对象所属的类没有覆盖Object的hashCode方法的话，hashCode会返回每个对象特有的序号（java是依据对象的内存地址计算出的此序号），所以两个不同的对象的hashCode值是不可能相等的。
如果想要让两个不同的Person对象视为相等的，就必须覆盖Object继下来的hashCode方法和equals方法，因为Object hashCode方法返回的是该对象的内存地址，所以必须重写hashCode方法，才能保证两个不同的对象具有相同的hashCode，同时也需要两个不同对象比较equals方法会返回true
    
---| Itreable      接口 实现该接口可以使用增强for循环
                ---| Collection        描述所有集合共性的接口
                    ---| List接口        可以有重复元素的集合
                            ---| ArrayList   
                            ---|  LinkedList
                    ---| Set接口        不可以有重复元素的集合
```

### String

`String` 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以`String` 对象是不可变的。

Object.java的equals函数：用于比较2个对象的**内存地址**是否相等，String类对该方法进行了**重写**用于比较字符串的**值**是否相等。

当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在**常量池**中重新创建一个 String 对象。

用new String（）创建的字符串不是常量，不能在编译期就确定，所以new String（）创建的字符串不放入常量池中，他们有自己的地址空间。
String 对象（内存）的不变性机制会使修改String字符串时，产生大量的对象，因为**每次改变字符串，都会生成一个新的String**。 java 为了更有效的使用内存，常量池在编译期遇见String 字符串时，它**会检查该池内是否已经存在相同的String 字符串**，如果找到，就**把新变量的引用指向现有的字符串对象**，不创建任何新的String 常量对象，没找到再创建新的。所以对一个字符串对象的任何修改，都会产生一个新的字符串对象，**原来的依然存在，等待垃圾回收**。

```java
String a = "a1"; 
String b = "a" + 1; 
System.out.println((a == b)); //result = true
String a = "atrue"; 
String b = "a" + "true"; 
System.out.println((a == b)); //result = true
String a = "a3.4"; 
String b = "a" + 3.4; 
System.out.println((a == b)); //result = true
JVM对于字符串常量的"+"号连接，将程序编译期，JVM就将常量字符串的"+"连接优化为连接后的值，拿"a" + 1来说，经编译器优化后在class中就已经是a1。在编译期其字符串常量的值就确定下来，故上面程序最终的结果都为true。

String a = "ab"; 
String bb = "b"; 
String b = "a" + bb; 
System.out.println((a == b)); //result = false
JVM对于字符串引用，由于在字符串的"+"连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即"a" + bb无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给b。所以上面程序的结果也就为false。
    

String a = "ab"; 
final String bb = "b"; 
String b = "a" + bb; 
System.out.println((a == b)); //result = true
和上面中唯一不同的是bb字符串加了final修饰，对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。所以此时的"a" + bb和"a" + "b"效果是一样的。故上面程序的结果为true。
    

String a = "ab"; 
final String bb = getBB(); 
String b = "a" + bb; 
System.out.println((a == b)); //result = false 
private static String getBB() {
return "b"; 
}
JVM对于字符串引用bb，它的值在编译期无法确定，只有在程序运行期调用方法后，将方法的返回值和"a"来动态连接并分配地址为b，故上面程序的结果为false。
    
    
class Test
{
	private static String a = "ab"; 
	public static void main(String[] args)
	{
	String s1 = "a";
	String s2 = "b";
	String s = s1 + s2;
	System.out.println(s == a);//false
	System.out.println(s.intern() == a);//true  
	}
}
这里用到Java里面是一个常量池的问题。对于s1+s2操作，其实是在堆里面重新创建了一个新的对象,s保存的是这个新对象在堆空间的的内容，所以s与a的值是不相等的。而当调用s.intern()方法，却可以返回s在常量池中的地址值，因为a的值存储在常量池中，故s.intern和a的值相等。
```

### 值传递

Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个**拷贝**，也就是说，方法不能修改传递给它的任何参数变量的内容。

**一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样**

```java
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5 };
        System.out.println(arr[0]);
        change(arr);
        System.out.println(arr[0]);
    }

    public static void change(int[] array) {
        // 将数组的第一个元素变为0
        array[0] = 0;
    }
//结果修改成功 1\n0
```

array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是 **堆中** 同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。理由很简单，方法得到的是对象**引用的拷贝**，对象引用及其他的拷贝同时引用同一个对象。

**既然这样，为什么说java是值传递，因为java的对象引用是按值传递的。**

把参数变成两个对象student1和student2就会发现函数内部的改变改变不了两个变量各自的值

### 深拷贝与浅拷贝

1. **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝（依然是同一个对象），此为浅拷贝。
2. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个**新的对象**，并复制其内容，此为深拷贝。

### 封装,继承,多态

把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。（重载）

### 存储

new 创建对象实例（对象实例在**堆内存**中），对象引用指向对象实例（对象引用存放在**栈内存**中）

对象（包括成员变量）存在于堆内存，局部变量存在于栈内存。

如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的。

### 反射

反射赋予我们在runtime时分析类以及执行类中方法的能力。

通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。

反射调用的最大好处就是配置性大大提高，就如同Spring IOC容器一样，我们可以给很多配置参数，使得java应用程序能够顺利运行起来，大大提高java的灵活性和可配置性，降低模块之间的耦合。

**动态代理**的实现依赖反射，**注解**的实现也用到了反射

为什么你使用 Spring 的时候 ，一个`@Component`注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 `@Value`注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？

这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。

### 双亲委派机制

当某个类加载器需要加载某个`.class`文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。

##### 作用

1、防止重复加载同一个`.class`。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
 2、保证核心`.class`不能被篡改。通过委托方式，不会去篡改核心`.class`，即使篡改也不会去加载，即使加载也不会是同一个`.class`对象了。不同的加载器加载同一个`.class`也不是同一个`Class`对象。这样保证了`Class`执行安全。

### I/O流

问题本质想问：**不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？**

回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

编码方式不同决定处理文件类型不同，字节流(ASCII)处理二进制文件，字符流(Unicode)处理文本文件，仅此而已。

实际上字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件，如下图所示。

缓冲区可以简单地理解为一段内存区域。**某些情况下，如果一个程序频繁地操作一个资源（如文件或数据库），则性能会很低，此时为了提升性能，就可以将一部分数据暂时读入到内存的一块区域之中，以后直接从此区域中读取数据即可，因为读取内存速度会比较快，这样可以提升程序的性能。**

字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性比较好！如果是音频文件、图片、歌曲，就用字节流好点，如果是关系到中文（文本）的，用字符流好点. 所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列. 1.字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 2. 字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以。 字节流与字符流主要的区别是他们的的**处理方式**

### HashMap

HashMap的hash操作的时间复杂度是O(1)，HashMap的equals操作的时间复杂度是O(n)。

HashMap在put元素时，首先会计算key的hashcode，这时候不会去调用equals方法。为什么呢？因为equals方法的时间复杂度是O(n)。但是HashMap存在hash碰撞问题，最坏的情况下，所有的key都被分配到了同一个桶，这时map的put和get时间复杂度都是O(n)。

##### put

1. 判断当前表是否为空，空的话就初始化
2. 根据key计算hashcode，定位到具体的桶，判断是否为空，空的话表面没有冲突，直接在当前位置创建一个新桶
3. 如果当前桶有值（hash冲突），判断桶的第一个位置的key与写入key是否相等，相等就赋值
4. 如果当前桶为红黑树，就按红黑树方式写入数据
5. 如果当前桶是链表，就将当前的key, value封装成一个新节点写入当前桶的后面
6. 接着判断当前链表大小是否大于阈值，大的话就转成红黑树
7. 最后判断是否需要resize

##### get

1. 根据key计算hashcode，取得定位的桶
2. 桶为空，返回null
3. 否则判断桶的第一个位置的key是否是要查的key
4. 如果第一个不匹配，判断当前桶是红黑树还是链表，按具体方式查找

#### resize

加长table的长度，减少hashcode冲突（让各个桶的元素数均衡点）

时间点有两处：1. 第一次插入时，通过resize构建table 2. HashMap.size > 阈值时，进行resize

size初始默认为16

jdk1.7的resize会让桶中节点元素顺序改变，因此在多线程访问中需要resize时会出现死循环问题

jdk1.8的resize不会改变节点顺序，因此没有倒排问题。但多线程还是会出现丢数据问题，所以要使用ConcurrentHashMap

#### 红黑树

jdk8中，链表长度超过8时，链表转成红黑树

#### 负载因子和初始容量

分别默认0.75和16

每次put后，会检测是否需要扩容，size超过了总容量*负载因子，则会扩容

初始容量16是因为容量为2的次幂时能保证key的hashcode做&运算后能均匀分布，减少hash冲突次数。取16是折中处理。

0.75也是这种处理，设置过小则扩容次数过多，过大则hash冲突概率增大。（统计学结果，hash冲突符合泊松分布）

#### ConcurrentHashMap

1.7是用基于分段segment思想，先hash确定在哪一个segment，再hash到具体位置，锁的粒度是segment，Segment继承自ReentrantLock。

HashEntry中的value用volatile关键字修饰，但还不能保证并发的原子性（volatile只保证读或写原子性不能保证读写原子性），所以put操作时仍需要加锁：先尝试获取锁，失败则自旋获取锁，重试次数超过阈值则改为阻塞锁获取，保证能成功。

1.8优化：红黑树，以及抛弃Segment分段锁（和ReentrantLock），改用**CAS+synchronized**的方式保证并发安全性。锁的粒度更小。

##### put

1. 根据key得到hashcode
2. 判断是否需要初始化
3. 根据key定位出的node，如果为空则表示当前位置可写数据，利用 **CAS** 尝试写入，失败则自旋
4. 如果当前位置的hashcode == -1，则需要扩容
5. 如果都不满足，则用syn锁写入数据
6. 如果数量大于桶阈值，就转成红黑树

##### get

1. 根据key得到hashcode
2. 如果在桶上直接返回值
3. 如果是红黑树就按树的方式遍历
4. 如果不满足就按链表方式遍历

### List

<img src="/list.png" style="zoom:50%;" />

图有争议

ArrayList和Vector中，从指定的位置检索一个对象，或在集合的末尾插入、删除一个元素的时间是一样的，时间复杂度都是O（1）。但是如果在其他位置增加或者删除元素花费的时间是O（n）,LinkedList中，在插入、删除任何位置的元素所花费的时间都是一样的，时间复杂度都为O（1），但是他在检索一个元素的时间复杂度为O（n）.

### Java关键字

#### Synchronized

同步，加锁

#### volatile

Java内存模型，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。

内存可见性：内存可见性是指当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。

**这里大家应该有个疑问是，为什么加锁(Synchronized)后就保证了变量的内存可见性了？** 因为当一个线程进入 synchronizer 代码块后，线程获取到锁，会**清空本地内存**，然后从主内存中**拷贝共享变量的最新值**到本地内存作为副本，执行代码，又将修改后的副本值**刷新到主内存**中，最后线程释放锁。

这里除了 synchronizer 外，其它锁也能保证变量的内存可见性。

比如本例中，Synchronized用于主线程中获取myThread，volatile用于修饰MyThread类中的共享变量flag

使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 **CPU 总线嗅探机制**告知其他线程该变量副本已经失效，需要重新从主内存中读取。

底层通过使用`lock`指令来实现volatile。其中`lock`指令在多核处理器下会有以下操作：

- 将当前处理器中缓存行中的数据立即写回主存。
- 数据写回主存后，会导致其他线程所持有的旧数据的内存地址数据无效。

从而保证了内存可见性。

#### static

方便在没有创建对象的情况下来进行调用（方法/变量）。

没有this方法，在static方法内部不能调用非静态方法，因为不依赖对象，反过来可以。

被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。不依附于任何对象。

Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。

静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。

static是不允许用来修饰局部变量

### GC

#### 垃圾回收算法

##### 算法

分代算法

新生代（伊甸区、from区、to区）——复制算法

老年代——标记清理/标记整理算法 stop the world

永久代——同老年代

##### 判断

可达性，计数器 判断对象是否存活

### TIP

大量零散的小对象，可以分配到栈上，这提供了一种很好的对象优化分配策略，栈上分配速度快，并且可以有效避免垃圾回收带来的负面影响。但是和堆空间相比，栈空间小，因此大对象不在栈上分配。

### Collection

#### ArrayList LinkedList HashSet

三者区别？使用场景？线程安全？

前二者为何按顺序存储，HashSet为何随机

### 类加载过程

#### 双亲委派机制

### 创建对象

#### new子类时，子类和父类静态代码块、构造器执行顺序

### 进程和线程

#### 二者区别

#### Runnable和Callable区别

callable接口可以让新建出来的线程给（主）线程返回一个值，外面用future接口的实现类的get拿到返回值

实现类是FutureTask

#### 线程池

##### 优点

重用线程，降低线程创建和销毁造成的消耗；提高响应速度；减少cpu切换线程、避免oom、减少保存和恢复现场次数

##### 参数

```java
int corePoolSize 核心线程数（常驻人员）
int maximumPoolSize 最大线程数（常驻人员+临时工）
long keepAliveTime 
TimeUnit unit
BlockingQueue<Runnable> workQueue 任务队列
RejectedExecutionHandler handler 执行策略
```

![](/th1.png)

![](/th2.png)

#### 阻塞队列

多线程环境中，用户无需关心什么时候阻塞线程，什么时候唤醒阻塞线程

如生产消费者模型：队列没数据时，消费者端所有线程会被自动阻塞，直到有数据进队列；队列中填满数据时，生产者端所有线程会自动阻塞

### String

String类是不可变类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。

这不是明明已经对他进行修改了吗？为什么还说他是一个不可变类呢？

<img src="/s1.png" style="zoom:80%;" />

#### StringBuffer

StringBuffer对象则代表一个字符序列可变的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()、toStirng()等方法可以改变这个字符串对象的字符序列。
<img src="/s2.png" style="zoom:75%;" />

StringBuffer对象是一个字符序列可变的字符串，它没有重新生成一个对象，而且在原来的对象中可以连接新的字符串。

StringBuffer类中的方法都添加了**synchronized关键字**，也就是给这个方法添加了一个锁，用来保证线程安全。

#### StringBuilder

StringBuilder类也代表可变字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：**StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。**

#### Java9 改进

Java9改进了字符串（包括String、StringBuffer、StringBuilder）的实现。在Java9以前字符串采用char[]数组来保存字符，因此字符串的每个字符占2字节；而Java9的字符串采用byte[]数组再加一个encoding-flag字段来保存字符，因此字符串的每个字符只占1字节。所以Java9的字符串更加节省空间，字符串的功能方法也没有受到影响。

### 锁

显示锁：需要程序员自己手动加锁解锁的如ReentrantLock

隐式锁：syn

#### jvm锁原理

每个java对象都有对象头Mark Work。当对象状态为偏向锁时MW存储偏向的线程id，当状态为轻量级锁时存储指向线程栈中lock record的指针，当为重量级锁时存储指向堆中的monitor对象的指针

**jvm锁在为对象加锁时，通过改变java对象的对象头Mark Work中锁的标志位来实现**

在java对象的对象头上，有一个锁的标记，如第一个线程执行程序时，检查java对象头中的锁标记，发现java对象头中的锁标记为未加锁状态，于是为java对象进行了加锁操作，将对象头中的锁标记设置为锁定状态。第二个线程执行同样的程序时，也会检查java对象头中的锁标记，此时会发现java对象头中的锁标记的状态为锁定状态，于是第二个线程会进入相应的 **阻塞队列** 中进行等待。

#### Synchronized

##### 底层原理

每个对象创建后都会存在一个Monitor，它的实现依赖底层OS的Mutex Lock实现，是重量级锁。（1.6后jvm内置锁进行了一系列优化）。syn锁编译成字节码后，jvm底层使用monitorenter与monitorexit来进行加锁和解锁。

syn加锁加在对象上，对象如何记录锁状态？用每个对象的对象头Mark Word记录。

##### 用处

* 作用于方法：锁住对象实例（this）

* 作用于静态方法：所著对象对应的class实例

  因为class数据存在于永久区，因此静态方法锁相当于该类的一个全局锁

* 作用于对象实例：锁住对应代码块

##### 底层详细

java的syn语法有两种：syn语句和syn方法。

* syn语句，当java源代码被javac编译成字节码时，会在同步块的入口位置和出口位置分别插入monitorenter和monitorexit字节码指令。
* syn方法，会被翻译成普通的方法调用和返回指令，在jvm字节码层面没有任何特别的指令，而是在class文件的方法表中将该方法的access_flag字段中的syn标志位置为1，表示该方法是同步方法，并将调用该方法的对象或该方法所属的class在jvm内部对象表示klass作为锁对象。

monitorenter和monitorexit字节码依赖于底层OS的mutex lock实现，但ML需要将当前线程挂起并从 **用户态** 切换到 **内核态** 来执行，代价高昂。1.6版本引入优化。

#### Lock

是一个接口，完全用java写，无关jvm实现。

##### ReentrantLock

Lock接口的一个实现，其所有方法实际上是调用了其一个静态内部类Sync中的方法，而Sync继承自**AbstractedQueuedSynchronizer**。

* 可重入

  通过计数器实现

* 公平级别锁和非公平级别锁

  默认是非公平级别，释放锁时任何一个锁都能竞争。公平级别是在非公平基础上加一个队列

相比syn多了几个功能：

* 等待可中断：持有锁的线程长期不放锁，等待的线程可以放弃等待
* 可实现公平锁：必须按照申请锁的时间顺序排队等待
* 锁可以绑定多个Condition对象（条件变量或条件队列）：syn中锁对象的wait notify notifyall方法可以实现一个隐含条件，但如果要和超过一个条件关联时，就要额外添加一个锁。而ReentrantLock无需这样做，只需多次调用newCondition()即可。

使用volatile来修饰state变量

**Unsafe包中的CAS**

unsafe包中方法都为native方法，所以cas用c++实现。实现cas时也用到了**lock指令**，所以cas也有volatile读和volatile写的内存语义

**fairLock与nonfairLock**

释放公平锁和非公平锁时，都会cas去写state变量。通过state（ReentrantLock一个重要的变量）可以知道锁是否被持有，如果state>0，表示当前锁有线程持有。如果state==0表示当前锁没有被任何线程持有。

##### AQS

利用CAS实现

**内部通过一个int类型的成员变量state来控制同步状态,当state=0时，则说明没有任何线程占有共享资源的锁，当state=1时，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待，AQS内部通过内部类Node构成FIFO的同步队列来完成线程获取锁的排队工作**

抽象队列同步器。同步器是用来构建锁及其他同步组件的基本框架，其实现主要是依赖一个volatile int类型的状态变量（0表示锁未被占用 1表示已占用）及通过一个FIFO队列共同构成**同步队列**。

通过内部类ConditionObject构建**条件等待队列**，来完成等待条件线程的排队工作。当线程调用Condition对象的wait方法后，会被加入等待队列中，当有线程调用Condition的signal方法后，线程将**从等待队列移动到同步队列**进行竞争。

AQS内部会有一个同步队列和可能的多个等待队列，前者存放等待获取锁的线程，后者分别存放等待不同条件的线程。

```txt
	AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。
	
	以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。

　　再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。

　　一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。
```



用户自定义同步器**只需要实现共享资源state的获取与释放方式即可**

AQS主要包括：

* 同步队列
* 独占时所的获取和释放
* 共享锁的获取和释放
* 超时等待锁及可中断锁的获取

**同步队列**：当多个线程竞争共享资源时，一个线程竞争到共享资源后，其他请求资源的线程会被阻塞，进入同步队列，这些线程等待cpu调度再次竞争共享资源。

AQS的同步队列由链表实现。其是带头尾节点的双向链表

#### Synchronized与Lock比较

* 都是可重入锁
* 都是独占锁
* 前者是java关键字，后者是接口
* 前者是原生语法层面的互斥锁，后者是api层面的互斥锁
* 前者修饰方法、类，后者修饰代码段，更灵活
* 前者的等待线程是阻塞态，后者的可以在一定时间后放弃等待

旧版本的syn性能低效，因为其是重量级锁，最大影响是阻塞的实现，挂起线程和恢复线程的操作都需要转到**内核态**中完成，给OS并发带来很大压力。而Lock性能更高。

1.6后的syn加入很多优化，如自适应锁、锁消除、锁粗化、轻量级锁、偏向锁等，不比lock差

#### jvm对锁的优化

* 锁粗化：减少不必要的紧连在一起的unlock、lock操作，将多个连续的锁扩展成一个范围更大的锁
* 锁消除：运行时jit编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护
* 轻量级锁：基于一个假设，在真实情况下程序中大部分同步代码一般处于无锁竞争状态，完全可以避免调用OS层面的重量级互斥锁，因此在monitorenter和monitorexit中只需要依靠一条CAS原子指令就能完全完成锁的获取和释放。当存在锁竞争情况下，执行CAS指令失败的线程将调用OS互斥锁进入阻塞态，当锁被释放时被唤醒。
* 偏向锁：为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令（这个线程之前已经拿过锁了，就不CAS了）
* 适应性自旋：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的OS重量级锁（mutex semaphore）前会进入忙等待然后再次尝试，当尝试一定次数后仍然没成功的化才调用与monitor关联的锁进入到阻塞态

总结：能不用阻塞态的OS层面重量级锁（mutex semaphore）就不用，尽量用CAS

#### ThreadLocal原理

线程内部的存储类，可以在指定线程内存储数据，数据存储后只有指定线程可以得到存储数据

其静态内部类ThreadLocalMap为每个Thread都维护了一个数组table（每个线程都有一个ThreadLocalMap）。（同一个线程内调用多个ThreadLocal，它们使用同一个table，每个ThreadLocal确定了一个数组下标，这个下标就是对应local对象的value存储的位置。）

就是每个线程都维护了一个map，而这个map的key就是threadLocal，而值就是我们set的那个值，每次线程在get的时候，都从自己的变量中取值，既然从自己的变量中取值，那肯定就不存在线程安全问题

##### 用途

当某些数据以线程为作用域并且不同线程具有不同数据副本时，就可以用ThreadLocal

变量是同一个，但每个线程都使用同一个初始值，也就是同一个变量的一个新副本

##### 与syn不同

* syn通过线程等待、牺牲时间来解决访问冲突
* ThreadLocal通过每隔线程单独一份存储空间、牺牲空间来解决冲突，且相对于syn，其具有线程隔离效果，只有线程内才能访问对应的值

#### jvm锁短板

synchronized和lock锁都是jvm级别的（jvm级别指当运行一个java程序时，会启动一个jvm进程来运行应用程序），也就是说二者在同一个java进程内有效，可以支持jvm同一进程内的线程互斥（保证高并发），但如果是分布式的，或者说app在不同的jvm进程中运行，就不行了。（分布式本质是将app部署到多个jvm实例中）

利用锁标志位的思想，所有进程的线程访问共享变量时，都到同一个地方检查当前程序的 **临界区** 是否进行了加锁操作，后者在统一的地方使用状态来标记。

#### redis实现分布式锁

##### 支持互斥性

使用redis的`SETNX` 命令实现分布式锁。

```#java
SETNX key value // key不存在时，设置其值为value，否则不做任何操作
// 成功返回1，失败返回0
```

##### 支持锁超时

以上还不够，会出现获取锁后在临界区执行（修改共享变量）过程中宕机的话会导致锁没有释放、其他工作者申请不到锁而产生的死锁问题

同时引用redis超时机制，设置缓存自动过期时间。

##### 支持加锁解锁操作绑定

使用ThreadLocal实现。程序尝试加锁时，先生成一个uuid，将生成的uuid绑定到当前线程，传递的key参数+uuid保存到redis中，同时设置超时时间。解锁时检查uuid是否与redis中的uuid相等，相等才会执行删除锁标志位操作。

##### 支持可重入性

计数器解决

##### 支持阻塞与非阻塞锁

自旋解决。将后续的请求（获取锁失败）进行阻塞，直到拿锁的请求释放锁后，再唤醒阻塞的请求。

##### 支持业务完整执行

要保证执行完业务再释放锁。每隔一段时间更新一下锁的过期时间（异步执行，开一个新线程执行这个定时任务）。

##### 总结

基于redis的分布式锁模型是AP架构。向节点1写入数据后，会立即返回结果，之后再redis中会以异步方式来同步数据。（zookeeper是CP架构，所以要等待大多数节点数据同步后才返回结果数据）

#### 可重入性

同一个线程能多次获取同一把锁，且能按顺序进行解锁操作。

使用计数器解决。加锁时+1，计数器为0时释放锁

### sort

先判断需排序的数据量是否大于60

小于60的，使用插入排序，因为插入稳定

大于60的，对基本类型使用快速排序（递归），对Object类型使用归并排序（非递归），因为快排不稳定，归并稳定，非递归能避免堆栈溢出风险

快排和归并在二分的时候小于60数据量的使用的也是插入排序