## 计算机网络

### TCP

#### 三次握手

客户端、服务器端都要确定对方有发送和接收能力

#### 四次挥手

比三次握手多了一个情景：数据正在传输，还没传输完

#### 冷启动 慢启动

#### 滑动窗口

#### 拥塞控制

### Socket

send函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。

recv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。

send是不是直接把数据发给服务端?
 不是，要想发数据，必须得通过**网卡**发送数据，应用程序是无法直接通过网卡发送数据的，它需要调用操作**系统接口**，也就是说，应用程序把发送的数据**先写入到发送缓冲区**(内存中的一片空间)，再由操作系统控制网卡把发送缓冲区的数据发送给服务端网卡 。

recv是不是直接从客户端接收数据?
 不是，应用软件是无法直接通过网卡接收数据的，它需要调用操作**系统接口**，由操作系统通过**网卡**接收数据，把接收的数据**写入到接收缓冲区**(内存中的一片空间），应用程序再从接收缓存区获取客户端发送的数据。

**send函数**

```c
int send( SOCKET s, const char FAR *buf, int len, int flags );
// 第一个参数指定发送端套接字描述符；
// 第二个参数指明一个存放应用程序要发送数据的缓冲区；
// 第三个参数指明实际要发送的数据的字节数；
// 第四个参数一般置0。 
```

同步Socket的send函数的执行流程 当调用该函数时：

  （1）先比较待发送数据len不能大于socket对象s的缓冲区长度

  （2）先检查协议是否正在发送s的缓冲区中的数据，如果是就等待协议把数据发送完，如果还没有发送或者缓冲区中没有数据，那么就比较s的发送缓冲区的剩余空间和len

  （3）如果len大于剩余空间大小，send就一直等待协议把s的发送缓冲中的数据发送完

  （4）如果len小于剩余空间大小，send就仅仅把buf中的数据copy到剩余空间里（注意并不是send把s的缓冲区中的数据传到连接的另一端的，那是协议传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里）。

如果send函数copy数据成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。

  要注意send函数把buf中的数据成功copy到s的发送缓冲区的剩余空间里后它就返回了，但是此时这些数据并不一定马上被传到连接的另一端。如果协议在后续的传送过程中出现网络错误的话，那么下一个Socket函数就会返回SOCKET_ERROR。（每一个除send外的Socket函数在执行的最开始总要先等待套接字的发送缓冲中的数据被协议传送完毕才能继续，如果在等待时出现网络错误，那么该Socket函数就返回 SOCKET_ERROR）

**recv函数**

类似send

先等待s的发送缓冲区中的数据被协议传送完毕

检查s的接收缓冲区，如果其中没有数据或者协议正在接收数据，那么recv就一直等待，当协议把数据接收完毕，recv就把s的接收缓冲区中的数据copy到buf对象中

### IO

https://blog.csdn.net/baixiaoshi/article/details/48708347?utm_source=copy

### 层

#### TCP/IP五层模型

* 应用层

  上层数据

  HTTP, FTP, SMTP, DNS

* 传输层

  数据段（TPC头部+上层数据），又叫数据报

  TCP/UDP

* 网络层

  数据包（IP头部+TCP头部+上层数据）

  IP, ARP, ICMP, IGMP

* 数据链路层

  数据帧（MAC头部+IP头部+TCP头部+上层数据）

* 物理层

  比特流

DHCP：动态主机配置协议，局域网中的计算机分配动态ip

HTTP：超文本传输协议，简单的请求-响应协议

HTTPs：在HTTP基础上进行加密和身份认证保证传输的安全性

FTP：允许用户存取指定类型与格式的文件，以及交互功能

SMTP：简单邮件传输协议，从源到目的地址的邮件传送规则

DNS域名解析系统：将域名解析为ip地址并提供范访问

ssh协议：建立在应用层和传输层基础上的安全协议

TCP：将数据分成IP段和，安全性高，传输数据前要握手

UDP：用户数据报协议，安全性不高，响应比TCP快

IP：负责计算机之间的通信，负责在因特网上发送和接收数据包

ICMP：用于在ip主机、路由器之间传递控制信息

IGMP：internet组管理协议

ARP：将ip地址解析成MAC地址

RARP：将MAC地址解析成ip地址

#### 数据封装与解封装

应用层发送上层数据经过传输层添加TCP头部，到达网络层添加IP头部，到达逻辑链路层添加MAC头部，到达物理层转化为010101的电信号等物理信号。

物理层接收到010101的物理信号后传递至逻辑链路层拆解MAC头部，数据到达网络层后拆解IP头部，到达传输层后拆解TCP头部，最后送达至应用层。

**注意：**每层都有数据段MSS的概念，指该层最大可容纳的有效数据长度，数据段加上头部就是该层的最大传输单元MTU

#### OSI七层模型

* 应用层：各种应用程序协议
* 表示层：信息的语法语义及它们的关联，如加密解密、转换翻译、压缩解压缩
* 会话层：不同机器上的用户之间建立及管理会话
* 传输层：接收上一层的数据，在必要时将数据进行分割，并将这些数据交给网络层，且保证这些数据段有效到达对端
* 网络层：控制子网的允许，如逻辑便知、分组传输、**路由选择**
* 数据链路层：物理寻址，同时将原始比特流转变成逻辑传输线路
* 物理层：机械电子定时接口通信信道上的原始比特流传输

传输层TCP与网络层IP都可以将数据切片

### DNS

域名服务器：将域名解析成ip地址

用户上网使用域名来访问网站

用户提交的请求不会直接发送给想要访问的网站，而是

* 首先发给域名服务器，服务器把域名解析成ip地址，返回给用户
* 用户收到ip地址，向该ip地址发起请求

#### DNS负载均衡

如果一个域名指向了多个IP地址，在每次域名解析时，DNS只要选一个返回给用户，就能够实现服务器集群的负载均衡。

##### 具体做法

设置一个调度策略，接下来的负载均衡完全由DNS服务器实现。当用户向我们的域名发起请求时，DNS服务器会自动根据我们之前设定好的策略选择一个合适的IP返回给用户，用户再向该IP发起请求。

* 随机分配
* 轮询
* 根据请求者的地域分配离他最近的服务器

##### 优点

* 最大的优点是配置简单

  服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。

* 具有较强的扩展性

  你完全可以为一个域名解析较多的IP，而且不用担心性能问题。

##### 缺点

* 不能方便地控制调度者（DNS）

  由于把集群调度权交给了DNS服务器，我们没办法随心所欲地控制调度者，没办法定制调度策略。

* DNS服务器不能了解每台服务器负载情况

  没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。

* DNS服务器对故障ip有缓存

  当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态DNS来解决。

#### 动态DNS

### 子网掩码

1、用于将一个大的IP网络划分为若干小的子网络：

有的网络多则几百台，有的只有区区几台，这样就浪费了很多IP地址，所以要划分子网。使用子网可以提高网络应用的效率。

2、用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上：

子网掩码一旦设置，网络地址和主机地址就固定了。子网一个最显著的特征就是具有子网掩码。与IP地址相同，子网掩码的长度也是32位，也可以使用十进制的形式。

## 操作系统

### 系统调用

我们运行的程序基本都是运行在用户态，如果要调用操作系统提供的系统态级别的子功能，那就需要系统调用

凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并**由操作系统代为**完成。

### 进程与线程

进程是资源分配的基本单位，线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。（线程是cpu调度的基本单位）

### 进程间通信

#### 管道

一种特殊的文件，只存在于内存中，实质是内核缓冲区

无名管道PIPE 半双工 父子进程

命名管道FIFO 半双工 允许无血缘进程间通信 在磁盘上有对应的节点，自身只有名字和访问节点的权限

#### 信号 Signal

比较复杂的通信方式，用于通知接收进程某个事件已经发生

#### 消息队列

是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。

消息队列 克服了管道信号传递信息少、只能承载无格式字节流及缓冲区大小受限等缺点

#### 共享存储（内存）

共享存储 最快的IPC 映射一段能被其他进程访问的内存，此内存由一个进程创建，但多个进程都可以访问 常与信号量配合

这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。

因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。

#### 信号量 Semaphores

是一个计数器

信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

信号量 计数器 可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

#### 套接字socket

可用于不同机器间的进程通信

套接字是**支持 TCP/IP 的网络通信的基本操作单元**，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

### 线程

一条线程指的是进程中一个单一顺序的控制流,一个进程中可以并发多个线程,每条线程并行执行不同的任务。

#### 线程5种状态

实现runnable接口和继承Thread可得一个线程类，new一个实例出来，就进入初始态

* 初始

* 可运行

  位于可运行线程池中，等待被线程调度选择，获取cpu使用权

  * 线程对象创建后，其他线程如main线程调用了该线程的**start()**方法
  * 当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，线程也会进入可运行态
  * 当前线程时间片用完，调用当前线程的yield()方法，当前线程也会进入可运行态
  * 锁池中的线程拿到对象锁后，也会进入可运行态

* 运行

  可运行的线程获得了cpu时间片，执行程序代码

* 阻塞**（重要）**

  线程因某种原因放弃了cpu使用权，暂时停止运行。

  直到线程进入可运行状态才有机会再次获得cpu使用权

  * 等待阻塞：运行态的线程执行**wait()方法**，jvm会把该线程放入阻塞队列中
  * 同步阻塞：运行态的线程在获取对象**同步锁**时，若该同步锁被其他线程占用，则jvm会把该线程放入锁池
  * 其他阻塞：运行态的线程执行**Thread.sleep()或t.join()方法**，或者**发出了I/O请求**，jvm会把该线程置为**阻塞**状态。当sleep超时、join等待线程终止或超时、**I/O处理完毕**时，线程重新转入**可运行状态**。

* 死亡

  线程run(), main()方法执行结束，或者因异常退出run()方法

#### sleep与wait区别

Wait()是等待别人释放资源，Sleep()是自己占用资源，去做等待

IO的阻塞相当于是sleep，虽然能停止但不释放资源。NIO采用IO multiplexing(IO多路复用，也叫异步阻塞IO，使用selector帮你去监听感兴趣的IO路径)。

* sleep是线程类Thread 的方法，它是使当前线程暂时睡眠，可以放在任何位置。而wait是Object类的方法，它是使当前线程暂时放弃对象的使用权进行等待，必须放在同步方法或同步块里。
* sleep使用的时候，线程并不会放弃对象的使用权，即不会释放对象锁，所以在同步方法或同步块中使用sleep，一个线程访问时，其他的线程也是无法访问的。wait是会释放对象锁的，就是当前线程放弃对象的使用权，让其他的线程可以访问。
* sleep只是暂时休眠一定时间，时间到了之后，自动恢复运行，不需另外的线程唤醒。线程执行wait方法时，需要另一个线程调用notify进行唤醒。

#### 拿到IO资源后是如何唤醒线程的？



### 线程间同步

线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。

1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2. **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
3. **事件(Event)** :Wait/Notify：通过**通知操作**的方式来保持**多线程同步**，还可以方便的实现多线程优先级的比较操作

#### Wait/Notify机制

举个栗子：餐厅里，厨师做好菜之后，通知等待中的服务员就是一个简单的等待通知机制

wait使线程停止运行，notify通知停止的线程继续执行

* wait：使当前执行代码的线程进入等待

  用来将当前线程置入“预执行队列”中，在wait所在的代码行处停止，直到接到通知或被终止为止。

  在wait之前，线程必须获得该对象的对象级别锁，即只有在同步方法或同步块中才能调用wait方法，wait方法执行后当前线程立即释放锁。

* notify：通知那些可能等待该对象的对象锁的**其他线程**

  notify方法在调用前，也要获得当前线程的对象级别的锁，即方法notify也要在同步方法或同步块中调用。

  在执行notify方法后，当前线程不会立马释放该对象锁，呈wait状态的线程不能立马获得该对象锁，需要等到notify所在的同步块执行完才会释放该对象锁。

### 中断

#### 含义

当出现需要时，cpu暂时停止当前程序的执行转而执行处理新情况的程序的这个过程。

#### 硬件中断与软件中断

硬件：硬件发出的中断信号，如I/O中断和硬件失效中断

* 由I/O控制器产生，用于发送信号通知操作完成等信号
* 掉电或存储器奇偶错之类故障

软件：程序中断和时钟中断

* 算数移除，除数为0
* 由处理器内部计时器产生，允许OS以一定规程执行函数（线程调度通过时钟中断实现）

#### 中断好处

有中断还是没有中断对于用户来说线程都是阻塞的，对于操作系统内核来说通过中断方式主动通知CPU的方式减少了线程轮询判断，提高了线程执行效率。

#### 流程

当外部设备的I/O模块准备好时，它会发送给CPU一个中断信号，CPU则会“立即”做出响应，暂停当前程序的处理去服务该I/O设备的程序。

当I/O设备完成一次I/O操作时，发送以下事件

* 开始I/O操作前，**处理器**将当前处理的相关信息（指令地址、必要的状态信息）保存到栈中，使得中断后可以恢复
* I/O操作完成后，**设备**给处理器发送一个中断信息
* 处理器响应中断信号
* 处理器对中断信号进行判断，若存在未响应的中断，则给产生中断信号的设备发送确认信号，确认信号使得设备取消它的中断信号
* **处理器将控制权转移给被中断程序**，被中断程序从栈中获取之前保存的信息，使得能继续执行I/O完成时的后续操作
* 处理器将**中断程序入口地址**载入到**程序计数器**中，使得程序计数器能继续执行下一个指令周期

#### 异步

调用异步操作后，API内部保存了相关状态机信息(回调信息)，线程继续执行其他操作，当操作系统内核读取数据完成时，线程调用回调方法恢复到`await`的后续操作。整个过程中线程不会因为阻塞带来导致性能损失。

### 软件开发的三层架构

高内聚低耦合

表示层UI，业务逻辑层BLL，数据访问层DAL