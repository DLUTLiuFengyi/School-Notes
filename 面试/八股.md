---
typora-root-url: pic
---

### Spring

#### Spring IoC

控制反转：对象的控制权交由程序管理而不是程序员

##### 如何实现

依赖注入：依赖关系由spring来解决。本来我接受各种参数来构造一个对象，现在只接受一个参数——已经实例化的对象。

spring通过xml配置读取要创建的对象的类名等属性信息，然后通过反射创建对象，放入bean容器中

#### Bean

Bean包括几个概念。

- 概念1：**Bean容器**，或称spring ioc容器，主要用来管理对象和依赖，以及依赖的注入。
- 概念2：bean是一个**Java对象**，根据bean规范编写出来的类，并由bean容器生成的对象就是一个bean。
- 概念3：bean规范。

#### Spring AOP

AOP：面向切面编程

切面：横切面，与纵切面（面向对象中如何更详细地描述一个对象）相对，是众多类都会使用到的与业务无关的常规操作（日志、安全认证、事务等）

#### Restful风格

#### Spring中的设计模式

- **工厂设计模式** : Spring使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。

- **代理设计模式** : Spring AOP 功能的实现。

- **单例设计模式** : Spring 中的 Bean 默认都是单例的。

  保证一个类只有一个实例，并提供一个访问它的全局访问点（构造方法是private的，外部不能调用）

- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。

- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。

- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。

- **适配器模式** :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。

单例模式补充：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。

### Spring Boot

### Spring MVC

* 用户发请求
* 控制器接收请求，调用业务类，派发页面
* 交给模型层处理：model service dao entity
* 模型层返回一个结果给控制器
* 控制器视图渲染 view
* 控制器响应给用户

**流程说明（重要）：**

1. 客户端（浏览器）发送请求，直接请求到 `DispatcherServlet`。
2. `DispatcherServlet` 根据请求信息调用 `HandlerMapping`，解析请求对应的 `Handler`。
3. 解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由 `HandlerAdapter` 适配器处理。
4. `HandlerAdapter` 会根据 `Handler `来调用真正的处理器来处理请求，并处理相应的业务逻辑。
5. 处理器处理完业务后，会返回一个 `ModelAndView` 对象，`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。
6. `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。
7. `DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。
8. 把 `View` 返回给请求者（浏览器）

### Mybatis

MyBatis 是一个支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和普通Java对象映射成数据库中的记录。

Mybatis的运行分为两个部分，第一部分是读取配置文件缓存到Configuration对象，用以创建SqlSessionFactory，第二部分是SqlSession的执行过程。

流程
1、使用XML配置文件或Java代码方式生产SqlSessionFactory

2、使用Resources类的getResourceAsStream()方法读取XML配置文件

3、使用SqlSessionFactoryBuilder类的build()方法创建sqlSessionFactory

4、得到sqlSessionFactory类后使用该类的openSession()获取SqlSession

5、得到SqlSession后需要实现映射器的功能，映射器有一个接口和该接口对应的XML映射文件或使用注解组成

6、使用SqlSession的getMapper()方法得到具体的接口类对象

步骤
1、创建MyBatis配置文件：mybatis-config.xml（不使用Java代码方式）（1）配置数据库环境（2）配置映射器的XML映射文件2、创建一个生成SqlSession的sqlSessionFactory类：SqlSessionFactoryUtils。对应流程的2、3、4

3、定义一个接口和该接口对应的XML映射文件：XxxMapper、XxxMapper.xml（不使用注解方式）

4、使用SqlSession的getMapper()方法得到具体的接口类对象

5、执行完业务后记得关闭sqlSession

### 分布式

CAP

一致性：所有数据节点数据一致（相比于ACID的C，只关注于一个事务内的数据约束）

可用性：每个操作都能在一定时间内返回结果（成功或失败）

分区容忍性：是否可以对数据进行分区

最终一致性：系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS

两阶段提交

1.请求阶段（commit-request phase，或称表决阶段，voting phase）
在请求阶段，协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。
在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地作业执行成功）或取消（本地作业执行故障）。

2.提交阶段（commit phase）
在该阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消。
当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务。
参与者在接收到协调者发来的消息后将执行响应的操作。

三阶段提交

在协调者与参与者中都引入超时机制

### MySQL

#### ACID

* 原子性：undo log实现
* 一致性：由另外三性综合保证
* 隔离性：加锁
* 持久性：redo log实现

#### 如何保证数据库数据的一致性

#### 为什么用B+树

索引的演化：

* 哈希索引：哈希值冲突，不支持排序
* 平衡二叉树：一个节点只能存一个索引，深度大
* B树：深度比二叉树浅，查找速度更快
* B+树：叶子节点才存数据（MyISAM存地址 InnoDB存具体数据），查找性能比B树稳定，叶子节点用链表形式连起来，对顺序查找支持友好，且不会有返回查找操作

#### Server层

* 连接
  * 先检查sql语句是否有权限
* （缓存）
* 分析
  * 词法：提取关键字，查询表名，字段名，查询条件
  * 语法：sql是否符合mysql语法
* 优化
  * 索引选择，关联顺序
* 执行
  * 调用引擎接口，返回结果

通用日志模块binlog（InnoDB日志是redo log）

#### 存储引擎层

数据的存储和读取，InnoDB

#### SQL执行

select：权限 分析 优化 权限 执行器 引擎

update：权限 分析 权限 执行器 引擎-redo-log(prepare状态)  binlog  redo-log(commit状态)

​				调用api写数据 InnoDB把数据保存在内存 记录redo-log redo-log进入prepare状态 告诉执行器执行完成 执行器收到并记录binlog 调用引擎接口 提交redo-log为提交状态

redo log两阶段提交：写完binlog后再提交redo log，是为了保证数据一致性

#### 查找很慢怎么办

思想：避免全表扫描，注意索引（注意where子句查询条件满足最左前缀原则），允许脏读

核心思想是：用一个或多个查询条件(查询条件要求至少输入一个)得到临时表，每个查询条件如果查到集合，就更新这张临时表，最后汇总的时候，只需判断这个临时表是否有值。以此类推，可以建立多个临时表，将查询条件汇总。

* 分析原SQL语句
* 优化设计
  * 用临时表扫描替代全表扫描
  * 用exists和not exists替代in或not in
  * 尽量不用模糊查询like
  * 建立适当索引
  * 避免*号

#### 各种锁

* 行锁：只有A事务commit后，B事务才可以对相同行进行更新（读），否则B会阻塞（读到A之前的值）
* 表锁：索引失效（or关键字）会让行级锁变成表锁，需要等事务Acommit之后
* 间隙锁：发生在范围查询中，要查主键id是1-9之间的数据，假如原有id 1 3 5 7 9，则现在是无法插如2 4 6之类的数据进去的

#### MVCC 多版本并发控制

为了提升并发性能，通过行级锁的变种，避免很多情况下的加锁的操作

适用于读已提交和可重复读

#### 慢查询日志

### 索引

为什么快？因为让无序数据变成有序（相对）

没有用索引的话需要遍历双向链表（叶子层）来定位对应的页，现在通过 **“目录”** 就可以很快地定位到对应的页上了！（从根节点从上往下，二分查找，时间复杂度近似为O(logn)）。其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。

* 经常需要搜索的列上
* 经常使用在where子句的列上
* 经常要排序的列上，利用索引的排序加快排序查询时间
* 中到大型表（特大型不合适，维护成本高）
* 经常连接的列上（主要是外键）
* 避免where子句中施加函数（会造成无法命中索引）

#### 数据结构

哈希索引：哈希表，查询性能最快

BTree索引：大部分场景

#### 引擎实现

MyISAM

B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。

InnoDB

其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

#### 注意

1. 单行访问是很慢的。特别是在机械硬盘存储中(SSD的随机I/O要快很多，不过这一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引，用以提升效率。
2. 按顺序访问范围数据是很快的，这有两个原因。第一，顺序 I/O 不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUPBY查询也无须再做排序和将行按组进行聚合计算了。
3. 索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就 不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访 问是很慢的。

#### InnoDB与MyISAM

* 前支持事务，后不支持
* 前支持外键，后不支持
* 前是聚集索引，后是非聚集索引
* 前最小锁粒度是行级锁，后是表锁，导致一个更新语句会让其他查询和更新都阻塞，并发受限
* 绝大多数只有读，则用MyISAM，读写频繁用InnoDB

聚集索引：数据存储与索引放在一块，索引结构的叶子节点保存了行数据

表数据按照索引的顺序来存储，即索引项的顺序与表中记录的物理顺序一致

InnoDB中在聚簇索引之上建立的索引称为辅助索引，像复合索引、前缀索引、唯一索引

聚簇索引默认是主键，若表中没有主键，则InnoDB...（唯一非空索引->内部生成隐式主键）

非聚簇索引：数据与索引分开存储，表数据存储顺序与索引顺序无关

前主索引B+树存的是主键id，叶子节点存的是数据

辅助索引存的是name，叶子只存有主键id，因此查找过程是先 辅助索引树 再 主键索引树

后叶子节点存的是物理地址

#### 最左前缀原则

如果查询的时候查询条件精确匹配索引的左边连续一列或几列（一定要从最左边那个开始），则此列就可以被用到（跟覆盖索引有所区别）。

如果建立的是复合索引，索引的顺序要按照建立时的顺序，即从左到右。

因为先给a列排序，再给b列排序，b只在a相同的情况下才有序

#### 索引实战

```mysql
select sql_no_cache * from user where phone='1365' and lan_id=121 and regoin_id=53;
alter table user add index idx_phone_lan_region(phone, lan_id, region_id);
```

加减乘除 != <> is null is not null or  函数如sum(), round()等会使索引失效

#### Java关键字

##### Synchronized

同步，加锁

##### volatile

Java内存模型，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。

内存可见性：内存可见性是指当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。

**这里大家应该有个疑问是，为什么加锁(Synchronized)后就保证了变量的内存可见性了？** 因为当一个线程进入 synchronizer 代码块后，线程获取到锁，会**清空本地内存**，然后从主内存中**拷贝共享变量的最新值**到本地内存作为副本，执行代码，又将修改后的副本值**刷新到主内存**中，最后线程释放锁。

这里除了 synchronizer 外，其它锁也能保证变量的内存可见性。

比如本例中，Synchronized用于主线程中获取myThread，volatile用于修饰MyThread类中的共享变量flag

使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 **CPU 总线嗅探机制**告知其他线程该变量副本已经失效，需要重新从主内存中读取。

### TCP

#### 三次握手

客户端、服务器端都要确定对方有发送和接收能力

#### 四次挥手

比三次握手多了一个情景：数据正在传输，还没传输完

### Socket

send函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。

recv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。

send是不是直接把数据发给服务端?
 不是，要想发数据，必须得通过**网卡**发送数据，应用程序是无法直接通过网卡发送数据的，它需要调用操作**系统接口**，也就是说，应用程序把发送的数据**先写入到发送缓冲区**(内存中的一片空间)，再由操作系统控制网卡把发送缓冲区的数据发送给服务端网卡 。

recv是不是直接从客户端接收数据?
 不是，应用软件是无法直接通过网卡接收数据的，它需要调用操作**系统接口**，由操作系统通过**网卡**接收数据，把接收的数据**写入到接收缓冲区**(内存中的一片空间），应用程序再从接收缓存区获取客户端发送的数据。

**send函数**

```c
int send( SOCKET s, const char FAR *buf, int len, int flags );
// 第一个参数指定发送端套接字描述符；
// 第二个参数指明一个存放应用程序要发送数据的缓冲区；
// 第三个参数指明实际要发送的数据的字节数；
// 第四个参数一般置0。 
```

同步Socket的send函数的执行流程 当调用该函数时：

  （1）先比较待发送数据len不能大于socket对象s的缓冲区长度

  （2）先检查协议是否正在发送s的缓冲区中的数据，如果是就等待协议把数据发送完，如果还没有发送或者缓冲区中没有数据，那么就比较s的发送缓冲区的剩余空间和len

  （3）如果len大于剩余空间大小，send就一直等待协议把s的发送缓冲中的数据发送完

  （4）如果len小于剩余空间大小，send就仅仅把buf中的数据copy到剩余空间里（注意并不是send把s的缓冲区中的数据传到连接的另一端的，那是协议传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里）。

如果send函数copy数据成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。

  要注意send函数把buf中的数据成功copy到s的发送缓冲区的剩余空间里后它就返回了，但是此时这些数据并不一定马上被传到连接的另一端。如果协议在后续的传送过程中出现网络错误的话，那么下一个Socket函数就会返回SOCKET_ERROR。（每一个除send外的Socket函数在执行的最开始总要先等待套接字的发送缓冲中的数据被协议传送完毕才能继续，如果在等待时出现网络错误，那么该Socket函数就返回 SOCKET_ERROR）

**recv函数**

类似send

先等待s的发送缓冲区中的数据被协议传送完毕

检查s的接收缓冲区，如果其中没有数据或者协议正在接收数据，那么recv就一直等待，当协议把数据接收完毕，recv就把s的接收缓冲区中的数据copy到buf对象中

### IO

https://blog.csdn.net/baixiaoshi/article/details/48708347?utm_source=copy

### GC

### 分布式

#### 高并发

#### 容灾

### 进程间通信

#### 管道

一种特殊的文件，只存在于内存中，实质是内核缓冲区

无名管道PIPE 半双工 父子进程

命名管道FIFO 半双工 允许无血缘进程间通信 在磁盘上有对应的节点，自身只有名字和访问节点的权限

#### 消息队列

是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。

消息队列 克服了管道信号传递信息少、只能承载无格式字节流及缓冲区大小受限等缺点

#### 共享存储

共享存储 最快的IPC 映射一段能被其他进程访问的内存，此内存由一个进程创建，但多个进程都可以访问 常与信号量配合

因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。

#### 信号量

信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

信号量 计数器 可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

套接字socket 可用于不同机器间的进程通信

信号 用于通知接收进程某个事件已经发生

### Java 基础

#### 编译与解释

两种皆有，编译器先将源程序编译成.class这种jvm能读懂的java字节，再用解释器解释成二进制机器码

#### jdk代理模式

JDK的动态代理，是由JDK的java.lang.reflect.*包提供支持的，我们需要完成这么几个步骤：
1、 编写服务类和接口，这个是真正的服务提供者，在JDK代理中接口是必须的
2、 编写代理类，提供绑定和代理方法
JDK代理最大的缺点就是需要接口，而mybatis的Mapper就是一个接口，它采用的就是JDK的动态代理。

#### jmm内存模型

#### hashcode

`hashCode()` 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。

用来缩小查找成本，不必要一直都直接用equals，而是先用hashcode，地址相等后再用equals进一步判断

**为什么重写 `equals` 时必须重写 `hashCode` 方法？**

`hashCode()`的默认行为是对堆上的对象产生独特地址。如果没有重写 `hashCode()`，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。**因此，equals 方法被覆盖过，则 `hashCode` 方法也必须被覆盖。**

**为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？**

因为 `hashCode()` 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关。

#### 常量池技术

java中有很多东西不会在运行过程中变化，编译器将源程序编译成class文件后，会用一部分字节分类存储这些代码。而这些字节我们就称为常量池。

常量池的出现是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复创建相等变量时节省了很多时间。

**常量池存在于方法区**

Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。

```java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true
Integer i11 = 333;
Integer i22 = 333;
System.out.println(i11 == i22);// 输出 false
Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false

Integer i1 = 40; //常量池技术
Integer i2 = new Integer(40); //创建新对象
System.out.println(i1 == i2);//输出 false
```

#### equals

**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。

**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

- 情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
- 情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

#### String

`String` 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以`String` 对象是不可变的。

Object.java的equals函数：用于比较2个对象的**内存地址**是否相等，String类对该方法进行了重写用于比较字符串的**值**是否相等。

当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在**常量池**中重新创建一个 String 对象。

用new String（）创建的字符串不是常量，不能在编译期就确定，所以new String（）创建的字符串不放入常量池中，他们有自己的地址空间。
String 对象（内存）的不变性机制会使修改String字符串时，产生大量的对象，因为**每次改变字符串，都会生成一个新的String**。 java 为了更有效的使用内存，常量池在编译期遇见String 字符串时，它**会检查该池内是否已经存在相同的String 字符串**，如果找到，就**把新变量的引用指向现有的字符串对象**，不创建任何新的String 常量对象，没找到再创建新的。所以对一个字符串对象的任何修改，都会产生一个新的字符串对象，**原来的依然存在，等待垃圾回收**。

```java

String a = "a1"; 
String b = "a" + 1; 
System.out.println((a == b)); //result = true
String a = "atrue"; 
String b = "a" + "true"; 
System.out.println((a == b)); //result = true
String a = "a3.4"; 
String b = "a" + 3.4; 
System.out.println((a == b)); //result = true
JVM对于字符串常量的"+"号连接，将程序编译期，JVM就将常量字符串的"+"连接优化为连接后的值，拿"a" + 1来说，经编译器优化后在class中就已经是a1。在编译期其字符串常量的值就确定下来，故上面程序最终的结果都为true。

String a = "ab"; 
String bb = "b"; 
String b = "a" + bb; 
System.out.println((a == b)); //result = false
JVM对于字符串引用，由于在字符串的"+"连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即"a" + bb无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给b。所以上面程序的结果也就为false。
    

String a = "ab"; 
final String bb = "b"; 
String b = "a" + bb; 
System.out.println((a == b)); //result = true
和上面中唯一不同的是bb字符串加了final修饰，对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。所以此时的"a" + bb和"a" + "b"效果是一样的。故上面程序的结果为true。
    

String a = "ab"; 
final String bb = getBB(); 
String b = "a" + bb; 
System.out.println((a == b)); //result = false 
private static String getBB() {
return "b"; 
}
JVM对于字符串引用bb，它的值在编译期无法确定，只有在程序运行期调用方法后，将方法的返回值和"a"来动态连接并分配地址为b，故上面程序的结果为false。
    
    
class Test
{
	private static String a = "ab"; 
	public static void main(String[] args)
	{
	String s1 = "a";
	String s2 = "b";
	String s = s1 + s2;
	System.out.println(s == a);//false
	System.out.println(s.intern() == a);//true  
	}
}
这里用到Java里面是一个常量池的问题。对于s1+s2操作，其实是在堆里面重新创建了一个新的对象,s保存的是这个新对象在堆空间的的内容，所以s与a的值是不相等的。而当调用s.intern()方法，却可以返回s在常量池中的地址值，因为a的值存储在常量池中，故s.intern和a的值相等。
```

#### 值传递

Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个**拷贝**，也就是说，方法不能修改传递给它的任何参数变量的内容。

**一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样**

```java
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5 };
        System.out.println(arr[0]);
        change(arr);
        System.out.println(arr[0]);
    }

    public static void change(int[] array) {
        // 将数组的第一个元素变为0
        array[0] = 0;
    }
//结果修改成功 1\n0
```

array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是 **堆中** 同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。理由很简单，方法得到的是对象**引用的拷贝**，对象引用及其他的拷贝同时引用同一个对象。

**既然这样，为什么说java是值传递，因为java的对象引用是按值传递的。**

把参数变成两个对象student1和student2就会发现函数内部的改变改变不了两个变量各自的值

#### 深拷贝与浅拷贝

1. **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝（依然是同一个对象），此为浅拷贝。
2. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个**新的对象**，并复制其内容，此为深拷贝。

#### 封装,继承,多态

把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。（重载）

#### 存储

new 创建对象实例（对象实例在**堆内存**中），对象引用指向对象实例（对象引用存放在**栈内存**中）

对象（包括成员变量）存在于堆内存，局部变量存在于栈内存。

如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的。

#### 反射

反射赋予我们在运行时分析类以及执行类中方法的能力。

通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。

反射调用的最大好处就是配置性大大提高，就如同Spring IOC容器一样，我们可以给很多配置参数，使得java应用程序能够顺利运行起来，大大提高java的灵活性和可配置性，降低模块之间的耦合。

**动态代理**的实现依赖反射，**注解**的实现也用到了反射

为什么你使用 Spring 的时候 ，一个`@Component`注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 `@Value`注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？

这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。

#### 双亲委派机制

当某个类加载器需要加载某个`.class`文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。

##### 作用

1、防止重复加载同一个`.class`。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
 2、保证核心`.class`不能被篡改。通过委托方式，不会去篡改核心`.class`，即使篡改也不会去加载，即使加载也不会是同一个`.class`对象了。不同的加载器加载同一个`.class`也不是同一个`Class`对象。这样保证了`Class`执行安全。

#### I/O流

问题本质想问：**不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？**

回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

编码方式不同决定处理文件类型不同，字节流(ASCII)处理二进制文件，字符流(Unicode)处理文本文件，仅此而已。

实际上字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件，如下图所示。

缓冲区可以简单地理解为一段内存区域。**某些情况下，如果一个程序频繁地操作一个资源（如文件或数据库），则性能会很低，此时为了提升性能，就可以将一部分数据暂时读入到内存的一块区域之中，以后直接从此区域中读取数据即可，因为读取内存速度会比较快，这样可以提升程序的性能。**

字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性比较好！如果是音频文件、图片、歌曲，就用字节流好点，如果是关系到中文（文本）的，用字符流好点. 所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列. 1.字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 2. 字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以。 字节流与字符流主要的区别是他们的的**处理方式**

#### HashMap

#### GC

##### 垃圾回收算法

### 并发

#### 线程池

### 设计模式

#### 代理模式

在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

### 实战

#### 服务限流

#### 100亿个数topk

### DNS

域名服务器：将域名解析成ip地址

用户上网使用域名来访问网站

用户提交的请求不会直接发送给想要访问的网站，而是

* 首先发给域名服务器，服务器把域名解析成ip地址，返回给用户
* 用户收到ip地址，向该ip地址发起请求

#### DNS负载均衡

如果一个域名指向了多个IP地址，在每次域名解析时，DNS只要选一个返回给用户，就能够实现服务器集群的负载均衡。

##### 具体做法

设置一个调度策略，接下来的负载均衡完全由DNS服务器实现。当用户向我们的域名发起请求时，DNS服务器会自动根据我们之前设定好的策略选择一个合适的IP返回给用户，用户再向该IP发起请求。

* 随机分配
* 轮询
* 根据请求者的地域分配离他最近的服务器

##### 优点

* 最大的优点是配置简单

  服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。

* 具有较强的扩展性

  你完全可以为一个域名解析较多的IP，而且不用担心性能问题。

##### 缺点

* 不能方便地控制调度者（DNS）

  由于把集群调度权交给了DNS服务器，我们没办法随心所欲地控制调度者，没办法定制调度策略。

* DNS服务器不能了解每台服务器负载情况

  没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。

* DNS服务器对故障ip有缓存

  当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态DNS来解决。

#### 动态DNS