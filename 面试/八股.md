---
typora-root-url: pic
---

### Spring

#### Spring IoC

控制反转：对象的控制权交由程序管理而不是程序员

##### 如何实现

依赖注入：依赖关系由spring来解决。本来我接受各种参数来构造一个对象，现在只接受一个参数——已经实例化的对象。

spring通过xml配置读取要创建的对象的类名等属性信息，然后通过反射创建对象，放入bean容器中

#### Bean

Bean包括几个概念。

- 概念1：**Bean容器**，或称spring ioc容器，主要用来管理对象和依赖，以及依赖的注入。
- 概念2：bean是一个**Java对象**，根据bean规范编写出来的类，并由bean容器生成的对象就是一个bean。
- 概念3：bean规范。

#### 常见注解

@Autowired 自动导入对象到类中， Spring 容器帮我们自动装配 bean

@GetMapping("users")` 等价于`@RequestMapping(value="/users",method=RequestMethod.GET)

@PostMapping("users")` 等价于`@RequestMapping(value="/users",method=RequestMethod.POST)

`@SpringBootApplication`就是几个重要的注解的组合，为什么要有它？当然是为了省事，避免了我们每次开发 Spring Boot 项目都要写一些必备的注解。

```java
@RestController
@RequestMapping("test")
public class HelloWorldController {
    @GetMapping("hello")
    public String sayHello() {
        return "Hello World";
    }
}

//浏览器 http://localhost:8333/test/hello 可以在页面正确得到 "Hello World" 
```

#### Spring AOP

AOP：面向切面编程

切面：横切面，与纵切面（面向对象中如何更详细地描述一个对象）相对，是众多类都会使用到的与业务无关的常规操作（日志、安全认证、事务等）

#### Restful风格

#### Spring中的设计模式

- **工厂设计模式** : Spring使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。

- **代理设计模式** : Spring AOP 功能的实现。

- **单例设计模式** : Spring 中的 Bean 默认都是单例的。

  保证一个类只有一个实例，并提供一个访问它的全局访问点（构造方法是private的，外部不能调用）

- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。

- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。

- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。

- **适配器模式** :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。

单例模式补充：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。

### Spring Boot

### Spring MVC

#### 结构

model处理数据逻辑的部分，通常负责在数据库中存取数据。

view处理数据显示的部分。通常是依据数据模型创建的。

controller处理数据交互的部分。通常负责从视图读取数据，控制用户输入，并向模型发送。

* 用户发请求
* 控制器接收请求，调用业务类，派发页面
* 交给模型层处理：model service dao entity
* 模型层返回一个结果给控制器
* 控制器视图渲染 view
* 控制器响应给用户

#### 流程说明（重要）

1. 客户端（浏览器）发送请求，直接请求到 `DispatcherServlet`。
2. `DispatcherServlet` 根据请求信息调用 `HandlerMapping`，解析请求对应的 `Handler`。
3. 解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由 `HandlerAdapter` 适配器处理。
4. `HandlerAdapter` 会根据 `Handler `来调用真正的处理器来处理请求，并处理相应的业务逻辑。
5. 处理器处理完业务后，会返回一个 `ModelAndView` 对象，`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。
6. `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。
7. `DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。
8. 把 `View` 返回给请求者（浏览器）

#### 优缺点

封装（分层）的思想，来降低耦合度，从而使我们的系统更灵活，扩展性更好。

优点

* 多个视图共享一个模型，大大提高代码的可重用性。
* 三个模块相互独立，改变其中一个不会影响其他两，所以具有良好的松耦合性。
* 控制器可以用来连接不同的模型和视图去完成用户的需求，灵活。

缺点

* 增加结构复杂度

* 视图其实与控制器会过于紧密

  视图没有控制器的存在，其应用是很有限的

* 视图对模型数据的访问低效

  依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。

### 分布式

#### CAP

一致性：所有数据节点数据一致（相比于ACID的C，只关注于一个事务内的数据约束）

可用性：每个操作都能在一定时间内返回结果（成功或失败）

分区容忍性：是否可以对数据进行分区

最终一致性：系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS。

两阶段提交

1.请求阶段（commit-request phase，或称表决阶段，voting phase）
在请求阶段，协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。
在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地作业执行成功）或取消（本地作业执行故障）。

2.提交阶段（commit phase）
在该阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消。
当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务。
参与者在接收到协调者发来的消息后将执行响应的操作。

三阶段提交

在协调者与参与者中都引入超时机制

#### 高并发

#### 容灾

### Java 基础

#### 存放地址

栈内存中的数据是可以共享的，常量存储的数据也是可以共享的，堆则不可以

栈中的数据大小和生命周期都是确定的，而堆中的数据大小和生命周期则是不确定的

成员变量存储在其所属的对象里面，也就说对象如果是引用存放在栈中，那么对象的成员变量自然也在栈中，如果说对象是new出来的，对象存储在堆中，那么对象的成员变量也在堆中。

##### 方法区

又叫静态区，被所有线程共享，包含所有**class和static变量**，即整个程序中永远唯一的元素

##### 堆

jvm只有一个堆区被所有线程共享，堆中不存放基本类型和对象引用，只存对象本身

##### 栈

存放函数参数和局部变量

每个线程包含一个栈区（局部方法栈 本地方法栈 程序计数器），栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中 

基础变量，局部变量，执行环境上下文，操作指令，对象的引用存在栈中，指向堆中对象对应的位置

#### 编译与解释

两种皆有，编译器先将源程序编译成.class这种jvm能读懂的java字节，再用解释器解释成二进制机器码

#### jdk代理模式

JDK的动态代理，是由JDK的java.lang.reflect.*包提供支持的，我们需要完成这么几个步骤：
1、 编写服务类和接口，这个是真正的服务提供者，在JDK代理中接口是必须的
2、 编写代理类，提供绑定和代理方法
JDK代理最大的缺点就是需要接口，而mybatis的Mapper就是一个接口，它采用的就是JDK的动态代理。

#### jmm内存模型

#### hashcode

`hashCode()` 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。

用来缩小查找成本，不必要一直都直接用equals，而是先用hashcode，地址相等后再用equals进一步判断

**为什么重写 `equals` 时必须重写 `hashCode` 方法？**

`hashCode()`的默认行为是对堆上的对象产生独特地址。如果没有重写 `hashCode()`，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。**因此，equals 方法被覆盖过，则 `hashCode` 方法也必须被覆盖。**

**为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？**

因为 `hashCode()` 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关。

#### 常量池技术

java中有很多东西不会在运行过程中变化，编译器将源程序编译成class文件后，会用一部分字节分类存储这些代码。而这些字节我们就称为常量池。

常量池的出现是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复创建相等变量时节省了很多时间。

**常量池存在于方法区**

Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。

```java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true
Integer i11 = 333;
Integer i22 = 333;
System.out.println(i11 == i22);// 输出 false
Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false

Integer i1 = 40; //常量池技术
Integer i2 = new Integer(40); //创建新对象
System.out.println(i1 == i2);//输出 false
```

#### equals

**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。

**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

- 情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
- 情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

#### String

`String` 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以`String` 对象是不可变的。

Object.java的equals函数：用于比较2个对象的**内存地址**是否相等，String类对该方法进行了重写用于比较字符串的**值**是否相等。

当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在**常量池**中重新创建一个 String 对象。

用new String（）创建的字符串不是常量，不能在编译期就确定，所以new String（）创建的字符串不放入常量池中，他们有自己的地址空间。
String 对象（内存）的不变性机制会使修改String字符串时，产生大量的对象，因为**每次改变字符串，都会生成一个新的String**。 java 为了更有效的使用内存，常量池在编译期遇见String 字符串时，它**会检查该池内是否已经存在相同的String 字符串**，如果找到，就**把新变量的引用指向现有的字符串对象**，不创建任何新的String 常量对象，没找到再创建新的。所以对一个字符串对象的任何修改，都会产生一个新的字符串对象，**原来的依然存在，等待垃圾回收**。

```java

String a = "a1"; 
String b = "a" + 1; 
System.out.println((a == b)); //result = true
String a = "atrue"; 
String b = "a" + "true"; 
System.out.println((a == b)); //result = true
String a = "a3.4"; 
String b = "a" + 3.4; 
System.out.println((a == b)); //result = true
JVM对于字符串常量的"+"号连接，将程序编译期，JVM就将常量字符串的"+"连接优化为连接后的值，拿"a" + 1来说，经编译器优化后在class中就已经是a1。在编译期其字符串常量的值就确定下来，故上面程序最终的结果都为true。

String a = "ab"; 
String bb = "b"; 
String b = "a" + bb; 
System.out.println((a == b)); //result = false
JVM对于字符串引用，由于在字符串的"+"连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即"a" + bb无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给b。所以上面程序的结果也就为false。
    

String a = "ab"; 
final String bb = "b"; 
String b = "a" + bb; 
System.out.println((a == b)); //result = true
和上面中唯一不同的是bb字符串加了final修饰，对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。所以此时的"a" + bb和"a" + "b"效果是一样的。故上面程序的结果为true。
    

String a = "ab"; 
final String bb = getBB(); 
String b = "a" + bb; 
System.out.println((a == b)); //result = false 
private static String getBB() {
return "b"; 
}
JVM对于字符串引用bb，它的值在编译期无法确定，只有在程序运行期调用方法后，将方法的返回值和"a"来动态连接并分配地址为b，故上面程序的结果为false。
    
    
class Test
{
	private static String a = "ab"; 
	public static void main(String[] args)
	{
	String s1 = "a";
	String s2 = "b";
	String s = s1 + s2;
	System.out.println(s == a);//false
	System.out.println(s.intern() == a);//true  
	}
}
这里用到Java里面是一个常量池的问题。对于s1+s2操作，其实是在堆里面重新创建了一个新的对象,s保存的是这个新对象在堆空间的的内容，所以s与a的值是不相等的。而当调用s.intern()方法，却可以返回s在常量池中的地址值，因为a的值存储在常量池中，故s.intern和a的值相等。
```

#### 值传递

Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个**拷贝**，也就是说，方法不能修改传递给它的任何参数变量的内容。

**一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样**

```java
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5 };
        System.out.println(arr[0]);
        change(arr);
        System.out.println(arr[0]);
    }

    public static void change(int[] array) {
        // 将数组的第一个元素变为0
        array[0] = 0;
    }
//结果修改成功 1\n0
```

array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是 **堆中** 同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。理由很简单，方法得到的是对象**引用的拷贝**，对象引用及其他的拷贝同时引用同一个对象。

**既然这样，为什么说java是值传递，因为java的对象引用是按值传递的。**

把参数变成两个对象student1和student2就会发现函数内部的改变改变不了两个变量各自的值

#### 深拷贝与浅拷贝

1. **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝（依然是同一个对象），此为浅拷贝。
2. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个**新的对象**，并复制其内容，此为深拷贝。

#### 封装,继承,多态

把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。（重载）

#### 存储

new 创建对象实例（对象实例在**堆内存**中），对象引用指向对象实例（对象引用存放在**栈内存**中）

对象（包括成员变量）存在于堆内存，局部变量存在于栈内存。

如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的。

#### 反射

反射赋予我们在运行时分析类以及执行类中方法的能力。

通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。

反射调用的最大好处就是配置性大大提高，就如同Spring IOC容器一样，我们可以给很多配置参数，使得java应用程序能够顺利运行起来，大大提高java的灵活性和可配置性，降低模块之间的耦合。

**动态代理**的实现依赖反射，**注解**的实现也用到了反射

为什么你使用 Spring 的时候 ，一个`@Component`注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 `@Value`注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？

这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。

#### 双亲委派机制

当某个类加载器需要加载某个`.class`文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。

##### 作用

1、防止重复加载同一个`.class`。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
 2、保证核心`.class`不能被篡改。通过委托方式，不会去篡改核心`.class`，即使篡改也不会去加载，即使加载也不会是同一个`.class`对象了。不同的加载器加载同一个`.class`也不是同一个`Class`对象。这样保证了`Class`执行安全。

#### I/O流

问题本质想问：**不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？**

回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

编码方式不同决定处理文件类型不同，字节流(ASCII)处理二进制文件，字符流(Unicode)处理文本文件，仅此而已。

实际上字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件，如下图所示。

缓冲区可以简单地理解为一段内存区域。**某些情况下，如果一个程序频繁地操作一个资源（如文件或数据库），则性能会很低，此时为了提升性能，就可以将一部分数据暂时读入到内存的一块区域之中，以后直接从此区域中读取数据即可，因为读取内存速度会比较快，这样可以提升程序的性能。**

字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性比较好！如果是音频文件、图片、歌曲，就用字节流好点，如果是关系到中文（文本）的，用字符流好点. 所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列. 1.字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 2. 字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以。 字节流与字符流主要的区别是他们的的**处理方式**

#### HashMap

HashMap的hash操作的时间复杂度是O(1)，HashMap的equals操作的时间复杂度是O(n)。

HashMap在put元素时，首先会计算key的hashcode，这时候不会去调用equals方法。为什么呢？因为equals方法的时间复杂度是O(n)。但是HashMap存在hash碰撞问题，最坏的情况下，所有的key都被分配到了同一个桶，这时map的put和get时间复杂度都是O(n)。

##### 红黑树

jdk8中，链表长度超过8时，链表转成红黑树

##### 负载因子和初始容量

分别默认0.75和16

每次put后，会检测是否需要扩容，size超过了总容量*负载因子，则会扩容

初始容量16是因为容量为2的次幂时能保证key的hashcode做&运算后能均匀分布，减少hash冲突次数。取16是折中处理。

0.75也是这种处理，设置过小则扩容次数过多，过大则hash冲突概率增大。

#### List

<img src="/list.png" style="zoom:50%;" />

图有争议

ArrayList和Vector中，从指定的位置检索一个对象，或在集合的末尾插入、删除一个元素的时间是一样的，时间复杂度都是O（1）。但是如果在其他位置增加或者删除元素花费的时间是O（n）,LinkedList中，在插入、删除任何位置的元素所花费的时间都是一样的，时间复杂度都为O（1），但是他在检索一个元素的时间复杂度为O（n）.

#### Java关键字

##### Synchronized

同步，加锁

##### volatile

Java内存模型，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。

内存可见性：内存可见性是指当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。

**这里大家应该有个疑问是，为什么加锁(Synchronized)后就保证了变量的内存可见性了？** 因为当一个线程进入 synchronizer 代码块后，线程获取到锁，会**清空本地内存**，然后从主内存中**拷贝共享变量的最新值**到本地内存作为副本，执行代码，又将修改后的副本值**刷新到主内存**中，最后线程释放锁。

这里除了 synchronizer 外，其它锁也能保证变量的内存可见性。

比如本例中，Synchronized用于主线程中获取myThread，volatile用于修饰MyThread类中的共享变量flag

使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 **CPU 总线嗅探机制**告知其他线程该变量副本已经失效，需要重新从主内存中读取。

##### static

方便在没有创建对象的情况下来进行调用（方法/变量）。

没有this方法，在static方法内部不能调用非静态方法，因为不依赖对象，反过来可以。

被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。不依附于任何对象。

Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。

静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。

static是不允许用来修饰局部变量

#### GC

##### 垃圾回收算法

#### 函数如何通过栈实现层层返回

线程执行的基本行为是函数调用，每次函数调用的数据都是通过Java栈传递的。

Java栈的主要内容是栈帧。每次函数调用都会有一个对应的栈帧被压入Java栈，每次函数调用结束(无论是正常返回或者抛出异常)，都会有一个栈帧被弹出Java栈。

<img src="/stack1.png" style="zoom:75%;" />

方法调用在jvm中转换成的是字节码执行，**字节码执行的数据结构就是栈帧**。jvm会为每个方法分配一个栈帧，当前线程正在活动的栈帧就是栈顶的栈帧

##### 栈帧数据结构

1. 局部变量表：保存函数参数和局部变量

   栈帧中的局部变量标准的槽位是可以复用的，如果一个局部变量表过了其作用域，那么在其作用域之后声明的变量就很有可能复用过期的局部变量表的槽位，达到节省资源的目的。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或者间接引用的对象都不会被垃圾回收。

2. 操作数栈

   与前者一样也是被组织成一个以字节为单位的数组，但与前者不同它不是通过索引访问而是通过标准的栈操作（压栈出栈）来访问。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。不同于程序计数器，Java虚拟机没有寄存器，程序计数器也无法被程序指令直接访问。Java虚拟机的指令是从操作数栈中而不是从寄存器中取得操作数的，因此它的运行方式是基于栈的而不是基于寄存器的。虽然指令也可以从其他地方取得操作数，比如从字节码流中跟随在操作码(代表指令的字节)之后的字节中或从常量池中，但是主要还是从操作数栈中获得操作数。

3. 动态链接：指向当前方法所在类型的运行时常量池的引用

   以便对当前的方法的代码实现动态链接。在class文件里，一个方法若要调用其他方法，或者访问成员变量，则需要通过符号引用来表示，**动态链接的作用就是将这些以符号引用表示的方法转换为实际方法的直接引用**。类加载的过程中将要解析尚未被解析的符号引用，并且将**对变量的访问转化访问这些变量的存储**。加载阶段或第一次使用时转化为直接引用的(将变量的访问转化为访问这些变量的存储结构所在的运行时内存位置)就叫做静态解析。

4. 方法返回地址

   方法正常返回会把返回值压入调用者的栈帧的操作数栈，**PC计数器的值就会调整到方法调用指令后面的一条指令**。这样使得当前的栈帧能够和调用者连接起来，并且让调用者的栈帧的操作数栈继续往下执行。

##### 栈上分配

栈上分配是jvm提供的一项优化技术：对那些线程私有的对象(指不能被其他线程访问到的对象)，可以将他们打散分配到栈上，而不是分配在堆上。其好处是可以在函数调用完毕自行销毁，而**不需要垃圾回收期介入**，从而提高了系统的性能。

栈上分配对象的技术基础是进行**逃逸分析**。逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。p1是成员变量，该字段可能被任何线程访问，属于逃逸对象；p2是局部变量，并且没有被返回，因此它并未发生逃逸，对这种情况，对象就可能被分配在栈上，而不是堆上。

#### TIP

大量零散的小对象，可以分配到栈上，这提供了一种很好的对象优化分配策略，栈上分配速度快，并且可以有效避免垃圾回收带来的负面影响。但是和堆空间相比，栈空间小，因此大对象不在栈上分配。

### 并发

#### 线程池

### 设计模式

#### 代理模式

在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

### Redis

### 高并发 高性能 高可用

#### 系统拆分

一个拆成多个，每个连接一个DB，这样就多个DB了

#### 缓存

必须。大部分高并发都是读多写少，完全可以在DB和缓存都写一份，读的时候走缓存。

redis单机几万并发。

#### 消息队列

必须。因为还是会出现高并发写。

大量的写请求灌入MQ，排队慢慢玩（排队等待），后边系统消费后慢慢写。

可以考虑异步写提高并发性。

#### 分库分表

DB层面。一个库拆成多个库来抗高并发，一个表拆成多个表提高跑sql性能。

#### 读写分离

大部分DB都是读多写少，没必要所有请求都集中在一个库上。搞个主从架构，主库写入从库读取。

#### ES

### Kafka

kafka其实有三个功能：消息队列，持久式存储，流式处理

#### 优势

大量使用批量处理和异步思想，最高每秒千万级

基于scala和java编写，大数据和流式处理生态兼容良好

#### 模型

##### 队列模型

队列作为消息通信载体，生产-消费者模式

缺点是不适用于：将生产者产生的消息分发给多个消费者且每个消费者都能接收到完整的消息内容

##### 发布-订阅模型

为了解决队列模型的问题

使用topic作为消息通信载体，类似广播，发布者发布一条消息，该消息通过topic传递给所有订阅者

队列模型是此模型的特例（只有一个订阅者）

#### 概念

producer生产者，consumer消费者，broker代理：独立的kafka实例，多个kafka broker组成一个kafka集群

partition分区：属于topic的一部分，一个topic有多个partition，同一topic下的partition可以分布在不同的broker，实际对应于消息队列里的队列

#### 多副本机制

为分区引入多副本机制，多副本间有leader，其他副本称为follower，我们发送的消息会被发送到leader，然后follower才能从leader中拉取消息进行同步

##### 好处

* 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）
* Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力

#### zookeeper

主要为kafka提供元数据管理

* broker注册：有一个专门**用来进行 Broker 服务器列表记录**的节点，每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到/brokers/ids 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去

* topic注册：同一个**Topic 的消息会被分成多个分区**并将其分布在多个 Broker 上，**这些分区信息及与 Broker 的对应关系**也都是由 Zookeeper 在维护

* 负载均衡： 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。

#### 如何保证消息消费顺序

每次添加消息到 Partition的时候都会采用尾加法

Kafka 只保证 Partition中的消息有序，而不能保证 Topic中的 Partition 的有序。

因此，如何保证 Kafka 中消息消费的顺序有下面两种方法：

1. 1 个 Topic 只对应一个 Partition。
2. （推荐）发送消息的时候指定 key/Partition。

消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。

#### 如何保证消息不丢失

##### 生产者丢失消息

检查失败原因，重新发送，可以设置重试次数、重试间隔

##### 消费者丢失消息

消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。

当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。

**手动关闭自动提交 offset，每次在真正消费完消息之后之后再自己手动提交 offset 。** 但是，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。

##### kafka丢失消息



### 3种缓存读写策略

热点数据可以提前放入cache中

#### 旁路缓存

适合读请求较多

服务端同时维护DB和cache，以DB结果为准

写：先更新DB，然后直接删除cache

读：从cache中读数据，读到就直接返回；读不到，从DB中读然后返回；服务器再把从DB获取到的数据放到cache中

##### 为什么不能先删除cache再更新DB？

因为为造成DB和cache数据不一致，比如请求1先写A，请求2随后读A的话会产生数据不一致（请求1先把cache中A删除，请求2从DB中读数据，请求1才把DB中的A更新成自己想更新的值）

那原理的先更新DB后删除cache的方法就没问题吗？

理论上还是会有不一致问题，但概率很小，因为cache写入的速度比DB写入的数据快很多

##### 缺点

* 首次请求数据一定不在cache

  解决：可先把热点数据提前放进cache

* 写较频繁的话cache中的数据会频繁被删除，会影响命中率

  解决1：强一致性场景的话，更新DB同时更新cache，加一个锁保证更新cache时线程安全

  解决2：短暂允许不一致场景的话，更新DB同时更新cache，但给cache加一个较短时间间隔，可保证即使数据不一致影响也较小

#### 读写穿透

服务端把cache视为主要数据存储，从中读取数据并将数据写入其中

cache负责将此数据读取和写入DB，减轻app(server?)职责

少用，因为cache写入DB功能少

写：先查cache，cache不在，直接更新DB；cache中存在，先更新cache，然后cache自己更新DB（同步更新）

读：从cache中读数据，读到就直接返回；读不到，cache自己从DB加载数据，然后返回

#### 异步缓存写入

也是由cache自己负责cache和DB的读写

Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新cache，不直接更新 DB，而是改为**异步批量**的方式来更新 DB。

消息队列中消息异步写入磁盘，InnoDB buffer pool机制

使用数据经常变化且对一致性要求不高，如浏览量、点赞量

### 实战

#### 服务限流

#### 100亿个数topk
